<!DOCTYPE html>

<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>AUTO MAP - CLUSTRO (Final Secured v12.2)</title>
<!-- 🔒 SECURITY HEADERS - 민감 정보 노출 및 XSS 방지 -->
<meta content="
  default-src 'self'; 
  script-src 'self' 'unsafe-inline' https://unpkg.com https://fonts.gstatic.com https://api.vworld.kr;
  style-src 'self' 'unsafe-inline' https://fonts.googleapis.com https://unpkg.com;
  font-src 'self' https://fonts.gstatic.com https://fonts.googleapis.com;
  img-src 'self' data: blob: https: http:;
  connect-src 'self' https: http:;
  frame-ancestors 'none';
  base-uri 'self';
  form-action 'self';
" http-equiv="Content-Security-Policy"/>
<meta content="nosniff" http-equiv="X-Content-Type-Options"/>
<meta content="DENY" http-equiv="X-Frame-Options"/>
<meta content="1; mode=block" http-equiv="X-XSS-Protection"/>
<meta content="strict-origin-when-cross-origin" http-equiv="Referrer-Policy"/>
<meta content="geolocation=(), microphone=(), camera=()" http-equiv="Permissions-Policy"/>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&amp;display=swap" rel="stylesheet"/>
<style>
/**
 * 🎨 DESIGN SYSTEM - 일관된 코딩 스타일과 반응형 디자인
 * 모든 CSS 변수와 클래스는 체계적으로 정리됨
 */
:root {
  /* 🎨 Color System - 접근성을 고려한 색상 대비 */
  --c-primary: #1F3A8A;
  --c-sky: #0EA5E9;
  --c-accent: #EA580C;
  --c-util: #334155;
  --c-success: #059669;
  --c-warning: #D97706;
  --c-danger: #DC2626;
  
  /* 📏 Layout System */
  --rail-w: 64px;
  --side-w: 380px;
  --gut-w: 6px;
  
  /* 📝 Typography System */
  --flt-font: 14px;
  --tbl-font: 14px;
  --font-family: 300 "Roboto", "Apple SD Gothic Neo", "Malgun Gothic", system-ui, sans-serif;
  
  /* 🗺️ Map System */
  --mk: 30px;
  
  /* 🎯 Animation System */
  --transition-fast: 0.15s ease;
  --transition-normal: 0.25s ease;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
  --shadow-md: 0 4px 6px rgba(0,0,0,0.07);
  --shadow-lg: 0 10px 15px rgba(0,0,0,0.1);
}

/* 📱 RESPONSIVE DESIGN - 다양한 화면 크기 지원 */
@media (max-width: 768px) {
  :root {
    --rail-w: 48px;
    --side-w: 280px;
    --flt-font: 12px;
    --tbl-font: 12px;
  }
  
  #app {
    grid-template-columns: var(--rail-w) 1fr;
    grid-template-areas: "rail toolbar" "rail main";
  }
  
  #lhs {
    position: fixed;
    left: -100%;
    top: 0;
    width: var(--side-w);
    height: 100vh;
    z-index: 9999;
    transition: left var(--transition-normal);
  }
  
  #lhs.mobile-open {
    left: var(--rail-w);
  }
  
  .mobile-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 9998;
    display: none;
  }
  
  .mobile-overlay.show {
    display: block;
  }
}

@media (max-width: 480px) {
  :root {
    --rail-w: 40px;
    --side-w: 100vw;
  }
  
  .icbtn span {
    display: none;
  }
}

/* 🎯 BASE STYLES */
* {
  box-sizing: border-box;
}

body {
  margin: 0;
  font: 14px/1.45 var(--font-family);
  color: #111;
  background: #fff;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

/* 📐 LAYOUT GRID */
#app {
  display: grid;
  min-height: 100vh;
  grid-template-columns: var(--rail-w) var(--side-w) var(--gut-w) 1fr;
  grid-template-rows: auto 1fr;
  grid-template-areas: "rail toolbar toolbar toolbar" "rail lhs gut rhs";
}

/* 🔧 TOOLBAR */
#toolbar {
  grid-area: toolbar;
  display: flex;
  align-items: center;
  gap: 8px;
  flex-wrap: wrap;
  padding: 8px 10px;
  border-bottom: 1px solid #e5e7eb;
  background: #fff;
  position: relative;
  z-index: 1000;
}

/* 🎛️ FORM CONTROLS - 일관된 스타일링 */
.form-control,
select,
input[type="text"],
input[type="file"],
input[type="number"],
input[type="url"],
input[type="search"] {
  padding: 7px 10px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  background: #fff;
  font-weight: 300;
  transition: all var(--transition-fast);
  font-family: inherit;
}

.form-control:focus,
select:focus,
input:focus {
  outline: none;
  border-color: var(--c-sky);
  box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.1);
}

.form-control:invalid {
  border-color: var(--c-danger);
}

/* 🏷️ BADGES & STATUS */
.badge {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid #e5e7eb;
  background: #fff;
  font-weight: 700;
  font-size: 12px;
  transition: all var(--transition-fast);
}

.badge.ok {
  border-color: #cfe9d5;
  color: var(--c-success);
  background: #f0fdf4;
}

.badge.warn {
  border-color: #fed7aa;
  color: var(--c-warning);
  background: #fffbeb;
}

.badge.bad {
  border-color: #fecaca;
  color: var(--c-danger);
  background: #fef2f2;
}

/* 🔘 BUTTONS - 향상된 버튼 시스템 */
.btn {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 8px 16px;
  border-radius: 8px;
  cursor: pointer;
  border: 1px solid transparent;
  font-weight: 600;
  font-size: 14px;
  text-decoration: none;
  transition: all var(--transition-fast);
  user-select: none;
  position: relative;
  overflow: hidden;
}

.btn::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
  transition: left 0.5s;
}

.btn:hover::before {
  left: 100%;
}

.btn-primary {
  background: var(--c-primary);
  border-color: var(--c-primary);
  color: #fff;
}

.btn-sky {
  background: var(--c-sky);
  border-color: var(--c-sky);
  color: #fff;
}

.btn-accent {
  background: var(--c-accent);
  border-color: var(--c-accent);
  color: #fff;
}

.btn-util {
  background: var(--c-util);
  border-color: var(--c-util);
  color: #fff;
}

.btn-outline {
  background: transparent;
  border-color: currentColor;
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
}

.btn:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
}

.btn:active:not(:disabled) {
  transform: translateY(0);
}

/* 📱 LEFT RAIL */
#rail {
  grid-area: rail;
  border-right: 1px solid #e5e7eb;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 8px 6px;
  gap: 8px;
  position: relative;
  z-index: 1001;
}

.logo-box {
  width: 56px;
  height: 56px;
  padding: 4px;
  border-radius: 14px;
  border: 1px solid #e5e7eb;
  background: #fff;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  box-shadow: var(--shadow-sm);
}

.logo-box svg {
  width: 48px;
  height: 48px;
  display: block;
}

.icbtn {
  width: 56px;
  border: 1px solid #e5e7eb;
  border-radius: 14px;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 8px 4px;
  cursor: pointer;
  transition: all var(--transition-fast);
  position: relative;
}

.icbtn svg {
  width: 22px;
  height: 22px;
  stroke: #111;
  fill: none;
  stroke-width: 2;
  transition: all var(--transition-fast);
}

.icbtn span {
  font-size: 11px;
  font-weight: 700;
  color: #111;
  transition: all var(--transition-fast);
}

.icbtn.active {
  background: var(--c-sky);
  border-color: var(--c-sky);
  box-shadow: var(--shadow-md);
}

.icbtn.active svg,
.icbtn.active span {
  stroke: #fff;
  color: #fff;
}

.icbtn:hover:not(.active) {
  box-shadow: var(--shadow-md);
  transform: translateY(-2px);
}

/* 📋 LEFT SIDEBAR */
#lhs {
  grid-area: lhs;
  border-right: 1px solid #e5e7eb;
  background: #fff;
  overflow: auto;
  font-size: var(--flt-font);
}

/* 🔍 DETAILS & ACCORDION */
details {
  border-bottom: 1px solid #f1f5f9;
}

details:last-child {
  border-bottom: none;
}

summary {
  list-style: none;
  cursor: pointer;
  padding: 14px 12px;
  font-weight: 700;
  display: flex;
  align-items: center;
  justify-content: space-between;
  transition: all var(--transition-fast);
  user-select: none;
}

summary::-webkit-details-marker {
  display: none;
}

summary::after {
  content: '+';
  font-size: 18px;
  font-weight: 300;
  transition: transform var(--transition-fast);
}

details[open] summary::after {
  transform: rotate(45deg);
}

summary:hover {
  background: #f8fafc;
}

details[open] summary {
  border-bottom: 1px solid #e2e8f0;
  background: #f8fafc;
}

.card {
  padding: 12px;
}

/* 🎯 LOADING & PROGRESS INDICATORS - 사용자 경험 개선 */
.loading {
  position: relative;
  pointer-events: none;
  opacity: 0.7;
}

.loading::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  margin: -10px 0 0 -10px;
  border: 2px solid #e5e7eb;
  border-top-color: var(--c-sky);
  border-radius: 50%;
  animation: spin 1s infinite linear;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.progress-bar {
  width: 100%;
  height: 4px;
  background: #f1f5f9;
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--c-sky);
  transition: width 0.3s ease;
  border-radius: 2px;
}

/* 🔔 NOTIFICATIONS & ALERTS */
.notification {
  position: fixed;
  top: 20px;
  right: 20px;
  padding: 12px 16px;
  border-radius: 8px;
  box-shadow: var(--shadow-lg);
  z-index: 10000;
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 500;
  transform: translateX(400px);
  transition: transform var(--transition-normal);
}

.notification.show {
  transform: translateX(0);
}

.notification.success {
  background: #f0fdf4;
  border: 1px solid #bbf7d0;
  color: #166534;
}

.notification.warning {
  background: #fffbeb;
  border: 1px solid #fed7aa;
  color: #92400e;
}

.notification.error {
  background: #fef2f2;
  border: 1px solid #fecaca;
  color: #991b1b;
}

/* 💾 PERFORMANCE OPTIMIZATIONS - 렌더링 최적화 */
.virtualized-list {
  height: 400px;
  overflow-y: auto;
}

.list-item {
  height: 40px;
  display: flex;
  align-items: center;
  padding: 0 12px;
  border-bottom: 1px solid #f1f5f9;
  will-change: transform;
}

/* 🔧 UTILITY CLASSES */
.small { font-size: 12px; color: #6b7280; font-weight: 400; }
.text-center { text-align: center; }
.text-right { text-align: right; }
.hidden { display: none !important; }
.sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); border: 0; }

/* 🎨 FORM LAYOUTS */
.row {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}

.row > * {
  flex: 1 1 auto;
}

.chips {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-top: 6px;
}

.chip {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  background: #f3f4f6;
  border: 1px solid #e5e7eb;
  border-radius: 999px;
  padding: 4px 8px;
  color: #111;
  font-size: 12px;
  transition: all var(--transition-fast);
  cursor: pointer;
  user-select: none;
}

.chip:hover {
  background: #e5e7eb;
  transform: translateY(-1px);
}

.chip input[type="checkbox"] {
  margin: 0;
}

/* 🎛️ SWITCHES */
.switch {
  position: relative;
  display: inline-block;
  width: 48px;
  height: 26px;
}

.switch input {
  display: none;
}

.slider {
  position: absolute;
  inset: 0;
  background: #e5e7eb;
  border: 1px solid #d1d5db;
  border-radius: 999px;
  transition: all var(--transition-normal);
  cursor: pointer;
}

.slider:before {
  content: "";
  position: absolute;
  width: 22px;
  height: 22px;
  left: 2px;
  top: 1px;
  background: #fff;
  border-radius: 50%;
  box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  transition: all var(--transition-normal);
}

.switch input:checked + .slider {
  background: var(--c-sky);
  border-color: var(--c-sky);
}

.switch input:checked + .slider:before {
  transform: translateX(22px);
}

/* 📏 RESIZER */
#gut {
  grid-area: gut;
  background: #f3f4f6;
  cursor: col-resize;
  transition: background var(--transition-fast);
}

#gut:hover {
  background: #e5e7eb;
}

/* 🗺️ MAP CONTAINER */
#rhs {
  grid-area: rhs;
  position: relative;
  background: #fafafa;
}

#map {
  position: absolute;
  inset: 0;
}

/* 🔘 MAP CONTROLS */
.map-bottom {
  position: absolute;
  right: 16px;
  bottom: 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  flex-wrap: wrap;
  z-index: 6500;
}

.toolbar-map {
  position: static;
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  z-index: 6500;
}

/* 🏷️ WATERMARK */
.wm {
  pointer-events: none;
  user-select: none;
  font: 700 14px/1 "Roboto", sans-serif;
  color: #fff;
  -webkit-text-stroke: 0.8px #000;
  text-shadow: 0 0 1px rgba(0,0,0,0.6);
}

#wm {
  position: fixed;
  bottom: 8px;
  right: 8px;
  z-index: 9999;
  background: rgba(255,255,255,0.8);
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 10px;
  color: #666;
  backdrop-filter: blur(4px);
}

/* 📋 PANELS */
.panel {
  position: absolute;
  right: 16px;
  bottom: 90px;
  width: min(640px, 60vw);
  max-height: 60vh;
  overflow: hidden;
  background: #fff;
  border: 1px solid #cbd5e1;
  border-radius: 12px;
  box-shadow: var(--shadow-lg);
  z-index: 6000;
  display: none;
  min-width: 360px;
  min-height: 220px;
  backdrop-filter: blur(10px);
}

.panel .head {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 16px;
  border-bottom: 1px solid #e2e8f0;
  background: #f8fafc;
  cursor: move;
  user-select: none;
}

.panel .head h4 {
  margin: 0;
  font-size: 14px;
  font-weight: 700;
}

.panel .body {
  overflow: auto;
  max-height: calc(60vh - 60px);
}

/* 📊 TABLES */
table {
  width: 100%;
  border-collapse: collapse;
  font-size: var(--tbl-font);
  border: 1px solid #e2e8f0;
}

thead th {
  position: sticky;
  top: 0;
  background: #f8fafc;
  border-bottom: 1px solid #e2e8f0;
  padding: 10px 8px;
  font-weight: 700;
  border-right: 1px solid #f1f5f9;
  text-align: left;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

tbody td {
  border-bottom: 1px solid #f1f5f9;
  border-right: 1px solid #f1f5f9;
  padding: 8px;
  font-weight: 400;
  background: #fff;
}

tbody tr:hover {
  background: #f8fafc;
}

tbody tr.selected {
  background: #eff6ff;
  border-color: var(--c-sky);
}

/* 🎯 MARKERS */
.mk {
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 800;
  line-height: 1;
  transform-origin: center;
  cursor: pointer;
  transition: all var(--transition-fast);
}

.mk-circle {
  width: var(--mk);
  height: var(--mk);
  border-radius: 50%;
  border: 2px solid #000;
  background: #fff;
  color: #000;
  box-shadow: var(--shadow-md);
  font-size: 12px;
}

.mk-tag {
  padding: 4px 8px;
  border-radius: 6px;
  background: #000;
  color: #fff;
  border: 2px solid #000;
  box-shadow: var(--shadow-md);
  font-size: 12px;
}

.mk-bubble {
  position: relative;
  padding: 4px 8px 6px 8px;
  border-radius: 6px;
  background: #fff;
  color: #000;
  border: 2px solid #000;
  box-shadow: var(--shadow-md);
  font-size: 12px;
}

.mk-bubble i {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  bottom: -7px;
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 8px solid #000;
}

.mk-bubble.sel {
  background: var(--c-danger);
  color: #fff;
  border-color: var(--c-danger);
}

.mk-bubble.sel i {
  border-top-color: var(--c-danger);
}

.mk.hover {
  transform: scale(1.15);
  z-index: 1000;
}

/* 🌙 DARK MODE SUPPORT */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-primary: #0f172a;
    --bg-secondary: #1e293b;
    --text-primary: #f1f5f9;
    --text-secondary: #94a3b8;
    --border-color: #334155;
  }
  
  body.auto-dark {
    background: var(--bg-primary);
    color: var(--text-primary);
  }
  
  .auto-dark #toolbar,
  .auto-dark #lhs,
  .auto-dark #rail,
  .auto-dark .panel {
    background: var(--bg-primary);
    border-color: var(--border-color);
    color: var(--text-primary);
  }
}

/* 🎮 ACCESSIBILITY IMPROVEMENTS */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

.focus-visible {
  outline: 2px solid var(--c-sky);
  outline-offset: 2px;
}

/* 🔧 ERROR HANDLING UI */
.error-boundary {
  padding: 20px;
  text-align: center;
  background: #fef2f2;
  border: 1px solid #fecaca;
  border-radius: 8px;
  margin: 20px;
}

.error-boundary h3 {
  color: var(--c-danger);
  margin-bottom: 10px;
}

/* 🎯 PERFORMANCE MONITORING */
.perf-monitor {
  position: fixed;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.8);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 10px;
  font-family: monospace;
  z-index: 10001;
  display: none;
}

.perf-monitor.show {
  display: block;
}

/* Print styles */
@media print {
  #rail, #lhs, .panel, .map-bottom { display: none !important; }
  #rhs { grid-column: 1 / -1; }
  body { background: white !important; }
}

<!-- Styles from NEW_WORLD_MAP_with_navigation.html -->

  :root{
    /* Adjusted theme variables for better contrast and readability */
    --c-primary:#1F3A8A; --c-sky:#0EA5E9; --c-accent:#EA580C; --c-util:#334155;
    --rail-w:64px; --side-w:380px; --gut-w:6px;
    /* increase default font sizes for filter and table for improved readability */
    --flt-font:14px; --tbl-font:14px;
    /* slightly larger marker size */
    --mk:30px;
  }

  /* Mobile-First Responsive Design */
  /* Mobile viewport meta and touch optimization */
  
  /* Base mobile styles for selection panel */
  #selPanel {
    overflow:auto !important; 
    height:auto !important; 
    max-height:none !important;
    /* Enhanced mobile touch interaction */
    touch-action: none;
    user-select: none;
    -webkit-user-select: none;
    -webkit-touch-callout: none;
  }
  
  /* Mobile-optimized watermark positioning */
  #wm{position:fixed; bottom:8px; right:8px; z-index:9999; background:rgba(255,255,255,0.7); padding:2px 6px; border-radius:4px; font-size:10px; pointer-events:none;}
  
  /* Enhanced mobile/tablet responsive design */
  @media screen and (max-width: 1024px) {
    /* Tablet optimizations */
    #mapControlsTop .btn {
      padding: 10px 14px !important;
      font-size: 15px !important;
      min-height: 42px !important;
    }
    
    #selPanel {
      min-width: 320px !important;
      max-width: calc(100vw - 24px) !important;
      /* Enhanced touch targets for tablet */
      -webkit-tap-highlight-color: transparent;
    }
    
    #selPanel .e-left, #selPanel .e-right { width: 28px !important; }
    #selPanel .e-top, #selPanel .e-bottom { height: 28px !important; }
    #selPanel .e-left { left: -18px !important; }
    #selPanel .e-right { right: -18px !important; }
    #selPanel .e-top { top: -23px !important; }
    #selPanel .e-bottom { bottom: -18px !important; }
  }
  
  @media screen and (max-width: 768px) {
    /* Keep buttons horizontal on mobile for better UX */
    #mapControlsTop {
      flex-direction: row !important;
      flex-wrap: wrap !important;
      gap: 6px !important;
      align-items: center !important;
      padding: 8px !important;
    }
    
    #mapControlsTop .btn {
      flex: 1 1 auto !important;
      min-width: 80px !important;
      padding: 10px 12px !important;
      font-size: 14px !important;
      min-height: 40px !important; /* Enhanced touch target */
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      white-space: nowrap !important;
      border-radius: 8px !important;
      font-weight: 500 !important;
    }
    
    /* Enhanced mobile panel positioning */
    #selPanel {
      right: 12px !important;
      bottom: 70px !important;
      min-width: 280px !important;
      max-width: calc(100vw - 24px) !important;
      min-height: 180px !important;
      max-height: calc(100vh - 140px) !important;
      border-radius: 16px !important;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12) !important;
    }
    
    /* Extra large touch targets for mobile */
    #selPanel .e-left, #selPanel .e-right { width: 35px !important; }
    #selPanel .e-top, #selPanel .e-bottom { height: 35px !important; }
    #selPanel .e-left { left: -22px !important; }
    #selPanel .e-right { right: -22px !important; }
    #selPanel .e-top { top: -27px !important; }
    #selPanel .e-bottom { bottom: -22px !important; }
    
    /* Mobile-optimized panel header */
    #selPanel .head {
      padding: 16px 20px !important;
      min-height: 56px !important;
      border-radius: 16px 16px 0 0 !important;
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%) !important;
    }
    
    #selPanel .head h4 {
      font-size: 17px !important;
      line-height: 1.3 !important;
      font-weight: 600 !important;
    }
    
    /* Enhanced mobile buttons */
    #selPanel .btn {
      padding: 10px 16px !important;
      font-size: 15px !important;
      min-height: 44px !important;
      border-radius: 10px !important;
      font-weight: 500 !important;
      transition: all 0.2s ease !important;
    }
    
    #selPanel .btn:active {
      transform: scale(0.98) !important;
      opacity: 0.8 !important;
    }
    
    /* Enhanced table scrolling for mobile */
    #selPanel table {
      font-size: 14px !important;
    }
    
    #selPanel th, #selPanel td {
      padding: 12px 8px !important;
      min-height: 44px !important;
    }
  }
  
  /* Ultra-mobile (small phones) */
  @media screen and (max-width: 480px) {
    #selPanel {
      right: 8px !important;
      bottom: 60px !important;
      min-width: 260px !important;
      max-width: calc(100vw - 16px) !important;
    }
    
    #selPanel .head {
      padding: 14px 16px !important;
      min-height: 52px !important;
    }
    
    #selPanel .head h4 {
      font-size: 16px !important;
    }
    
    #selPanel table {
      font-size: 13px !important;
    }
  }
  
  /* Tablet optimizations */
  @media screen and (min-width: 769px) and (max-width: 1024px) {
    #mapControlsTop .btn {
      padding: 10px 14px !important;
      font-size: 15px !important;
      min-height: 42px !important;
    }
    
    #selPanel {
      min-width: 400px !important;
      max-width: calc(100vw - 32px) !important;
    }
  }
  
  /* Touch device optimizations */
  @media (pointer: coarse) {
    /* Increase touch targets for all interactive elements */
    .btn, button, input, select {
      min-height: 44px !important;
      padding: 12px 16px !important;
    }
    
    /* Enhanced resize handle visibility on touch devices */
    #selPanel .e-left::before,
    #selPanel .e-right::before,
    #selPanel .e-top::before,
    #selPanel .e-bottom::before {
      content: '';
      position: absolute;
      background: rgba(59, 130, 246, 0.1);
      border: 2px solid rgba(59, 130, 246, 0.3);
      border-radius: 4px;
    }
    
    #selPanel .e-left::before,
    #selPanel .e-right::before {
      top: 50%;
      transform: translateY(-50%);
      width: 6px;
      height: 40px;
      left: 50%;
      margin-left: -3px;
    }
    
    #selPanel .e-top::before,
    #selPanel .e-bottom::before {
      left: 50%;
      transform: translateX(-50%);
      height: 6px;
      width: 40px;
      top: 50%;
      margin-top: -3px;
    }
  }
  *{box-sizing:border-box}
  body{margin:0;font:14px/1.45 300 "Roboto","Apple SD Gothic Neo","Malgun Gothic",system-ui,sans-serif;color:#111;background:#fff}
  #app{display:grid; min-height:100vh;
    grid-template-columns:var(--rail-w) var(--side-w) var(--gut-w) 1fr;
    grid-template-rows:auto 1fr;
    grid-template-areas:"rail toolbar toolbar toolbar" "rail lhs gut rhs";}

  /* toolbar */
  #toolbar{grid-area:toolbar;display:flex;align-items:center;gap:8px;flex-wrap:wrap;padding:8px 10px;border-bottom:1px solid #e5e7eb;background:#fff}
  .small{font-size:12px;color:#6b7280;font-weight:400}
  select,input[type="text"],input[type="file"],input[type="number"],input[type="url"]{padding:7px 10px;border:1px solid #d1d5db;border-radius:10px;background:#fff;font-weight:300}
  .badge{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;border:1px solid #e5e7eb;background:#fff;font-weight:700}
  .badge.ok{border-color:#cfe9d5;color:#137333;background:#f3fbf5}
  .badge.warn{border-color:#f6e4b3;color:#b08900;background:#fff9e6}
  .badge.bad{border-color:#f3c5c5;color:#c92a2a;background:#fff2f2}
  .btn{padding:7px 12px;border-radius:10px;cursor:pointer;border:1px solid transparent;font-weight:700;color:#fff}
  .btn-primary{background:var(--c-primary);border-color:var(--c-primary)}
  .btn-sky{background:var(--c-sky);border-color:var(--c-sky)}
  .btn-accent{background:var(--c-accent);border-color:var(--c-accent)}
  .btn-util{background:var(--c-util);border-color:var(--c-util)}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn:hover{filter:brightness(.98)}

  /* left rail */
  #rail{grid-area:rail;border-right:1px solid #e5e7eb;background:#fff;display:flex;flex-direction:column;align-items:center;padding:8px 6px;gap:8px}
  .logo-box{width:56px;height:56px;padding:4px;border-radius:14px;border:1px solid #e5e7eb;background:#fff;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .logo-box svg{width:48px;height:48px;display:block}
  .icbtn{width:56px;border:1px solid #e5e7eb;border-radius:14px;background:#fff;display:flex;flex-direction:column;align-items:center;gap:4px;padding:8px 4px;cursor:pointer;transition:.15s}
  .icbtn svg{width:22px;height:22px;stroke:#111;fill:none;stroke-width:2}
  .icbtn span{font-size:11px;font-weight:700;color:#111}
  .icbtn.active{background:var(--c-sky);border-color:var(--c-sky)}
  .icbtn.active svg,.icbtn.active span{stroke:#fff;color:#fff}
  .icbtn:hover{box-shadow:0 2px 10px rgba(0,0,0,.06)}

  /* lhs */
  #lhs{grid-area:lhs;border-right:1px solid #e5e7eb;background:#fff;overflow:auto;font-size:var(--flt-font)}
  details{border-bottom:1px dashed #e5e7eb}
  summary{list-style:none;cursor:pointer;padding:14px 12px;font-weight:700;display:flex;align-items:center;justify-content:space-between}
  details[open] summary{border-bottom:1px dashed #eef2f7}
  .card{padding:12px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .row>*{flex:1 1 auto}
  .chips{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px}
  .chip{display:inline-flex;align-items:center;gap:6px;background:#f3f4f6;border:1px solid #e5e7eb;border-radius:999px;padding:4px 8px;color:#111}

  /* switches */
  .switch{position:relative;display:inline-block;width:48px;height:26px}
  .switch input{display:none}
  .slider{position:absolute;inset:0;background:#e5e7eb;border:1px solid #d1d5db;border-radius:999px;transition:.2s}
  .slider:before{content:"";position:absolute;width:22px;height:22px;left:2px;top:1px;background:#fff;border-radius:50%;box-shadow:0 1px 3px rgba(0,0,0,.2);transition:.2s}
  .switch input:checked + .slider{background:var(--c-sky);border-color:var(--c-sky)}
  .switch input:checked + .slider:before{transform:translateX(22px)}

  /* gut */
  #gut{grid-area:gut;background:#f3f4f6;cursor:col-resize}

  /* map */
  #rhs{grid-area:rhs;position:relative;background:#fafafa}
  #map{position:absolute;inset:0}

  /* map bottom toolbar */
  .map-bottom{position:absolute;right:16px;bottom:16px;display:flex;align-items:center;gap:12px;flex-wrap:wrap;z-index:6500}
  .toolbar-map{position:static;display:flex;gap:8px;flex-wrap:wrap;z-index:6500}
  .wm{pointer-events:none;user-select:none;font:700 14px/1 "Roboto",sans-serif;color:#fff;-webkit-text-stroke:0.8px #000;text-shadow:0 0 1px rgba(0,0,0,.6)}

  /* panel */
  .panel{position:absolute;right:16px;bottom:90px;width:min(640px,60vw);max-width:80vw;max-height:56vh;overflow:auto;background:#fff;border:1px solid #cbd5e1;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.08);z-index:6000;display:none;min-width:360px;min-height:220px}
  .panel .head{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:2px solid #cbd5e1;background:#f8fafc;cursor:move;user-select:none}
  .panel .head h4{margin:0;font-size:13px;font-weight:700}
  .panel .edge{position:absolute;background:transparent}
  .panel .e-left{left:-16px;top:0;width:22px;height:100%;cursor:ew-resize}
  .panel .e-right{right:-16px;top:0;width:22px;height:100%;cursor:ew-resize}
  .panel .e-top{top:-20px;left:0;width:100%;height:24px;cursor:ns-resize}
  .panel .e-bottom{bottom:-16px;left:0;width:100%;height:22px;cursor:ns-resize}
  .panel.dragging .edge{pointer-events:none;opacity:0}
  .panel.resizing .head{pointer-events:none;cursor:default}

  table{width:100%;border-collapse:collapse;font-size:var(--tbl-font);border:1px solid #cbd5e1}
  thead th{position:sticky;top:0;background:#f1f5f9;border-bottom:2px solid #cbd5e1;padding:7px 8px;font-weight:700;border-right:1px solid #e2e8f0}
  tbody td{border-bottom:1px solid #e2e8f0;border-right:1px solid #e2e8f0;padding:6px 8px;font-weight:400;background:#fff}
  tbody tr:hover{background:#f8fafc}
  .row-actions{text-align:center;width:42px}
  .btn-del{cursor:pointer}
  th.has-resizer{position:relative}
  .th-resizer{position:absolute;top:0;right:-3px;width:6px;height:100%;cursor:col-resize}

  /* markers */
  .mk{display:flex;align-items:center;justify-content:center;font-weight:800;line-height:1;transform-origin:center}
  .mk-circle{width:var(--mk);height:var(--mk);border-radius:50%;border:2px solid #000;background:#fff;color:#000;box-shadow:0 1px 0 rgba(0,0,0,.35);font-size:12px}
  .mk-tag{padding:4px 8px;border-radius:6px;background:#000;color:#fff;border:2px solid #000;box-shadow:0 1px 0 rgba(0,0,0,.35);font-size:12px}
  .mk-bubble{position:relative;padding:4px 8px 6px 8px;border-radius:6px;background:#fff;color:#000;border:2px solid #000;box-shadow:0 1px 0 rgba(0,0,0,.35);font-size:12px}
  .mk-bubble i{position:absolute;left:50%;transform:translateX(-50%);bottom:-7px;width:0;height:0;border-left:6px solid transparent;border-right:6px solid transparent;border-top:8px solid #000}
  .mk-bubble.sel{background:#DC2626;color:#fff;border-color:#DC2626}
  .mk-bubble.sel i{border-top-color:#DC2626}
  .mk.hover{transform:scale(1.12)}

  .mbar{position:absolute;left:72px;top:12px;z-index:6500;display:flex;gap:6px;pointer-events:auto}

  .bw #map{filter:grayscale(100%) contrast(105%)}
  body.dark{background:#0b1220;color:#e5e7eb}
  body.dark #toolbar, body.dark #lhs, body.dark .panel{background:#0f172a;color:#e5e7eb}
  body.dark #lhs, body.dark .panel{border-color:#1f2937}
  body.dark details{border-color:#1f2937}
  body.dark summary{color:#e5e7eb}
  body.dark .card{background:#0f172a}
  body.dark select, body.dark input[type="text"], body.dark input[type="file"], body.dark input[type="number"]{background:#0b1220;color:#e5e7eb;border-color:#334155}
  body.dark .chip{background:#0b1322;border-color:#243041;color:#e5e7eb}
  body.dark .panel .head{background:#0b1322;border-bottom-color:#243041}
  body.dark table{background:#0f172a;border-color:#243041}
  body.dark thead th{background:#0b1322;border-bottom-color:#243041;border-right-color:#243041}
  body.dark tbody td{background:#0f172a;border-right-color:#243041;border-bottom-color:#243041}
  body.dark #rail{background:#0f172a;border-color:#1f2937}
  body.dark .icbtn{background:#0f172a;border-color:#243041}
  body.dark .icbtn svg{stroke:#e5e7eb}
  body.dark .icbtn span{color:#e5e7eb}
  body.dark .badge{background:#111827;border-color:#374151;color:#E5E7EB}
  body.dark .badge.ok{background:#0f1a14;border-color:#1a3c2a;color:#8bf0b2}
  body.dark .badge.warn{background:#2a2310;border-color:#4b3a0e;color:#ffd36a}
  body.dark .badge.bad{background:#2a1212;border-color:#4b1e1e;color:#ff9e9e}

<!-- Styles from NEW_WORLD_MAP_with_navigation.html -->

  /* 선택목록 패널: 4변 리사이즈 핸들(패널 밖 14~20px 띠) */
  #selPanel{position:absolute; right:16px; bottom:90px; min-width:360px; min-height:220px;}
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel.dragging .edge{pointer-events:none}
  /* 지도 상호작용 차단용 실드 */
  #mapShield{position:absolute; inset:0; background:transparent; z-index:5999; display:none}
  /* 경로 외 마커 숨김 적용 시, 숨김 처리를 위한 클래스 */
  .clo-hidden{opacity:0 !important; pointer-events:none !important}

<!-- Styles from NEW_WORLD_MAP_with_navigation.html -->

  /* 선택목록 패널 - fixed 고정 + 4변 리사이즈 핸들 */
  #selPanel{
    position:fixed !important;
    right:16px; bottom:90px;
    min-width:360px; min-height:220px;
    will-change:left, top, width, height, transform;
    transform:translateZ(0);
    z-index:6000;
  }
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel.dragging .edge{pointer-events:none}

  /* 지도 차단 실드(패널 hover/drag/resize 동안) */
  #mapShield{position:fixed; inset:0; display:none; background:transparent; z-index:5999}

  /* 경로 외 마커 숨김 때 사용 */
  .clo-hidden{opacity:0 !important; pointer-events:none !important}

<!-- Styles from NEW_WORLD_MAP_with_navigation.html -->

  /* 드래그 중 텍스트 선택 방지 */
  .clo-noselect { user-select: none !important; }

<!-- Styles from NEW_WORLD_MAP_with_navigation.html -->

  /* 드래그 중 텍스트 선택 방지 */
  .clo-noselect { user-select: none !important; }
  /* 선택목록 패널 기본 고정값(있어도 무방) */
  #selPanel{
    position:fixed !important;
    min-width:360px; min-height:220px;
    z-index:6000; transform:translateZ(0);
  }
  /* 4변 리사이즈 핸들 – 표 바깥 띠 */
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel.dragging .edge{pointer-events:none}

  /* 지도 차단용 투명 실드(없으면 주입됨) */
  #mapShield{position:fixed; inset:0; display:none; background:transparent; z-index:5999}

<!-- Styles from NEW_WORLD_MAP_with_navigation.html -->

  /* 드래그 중 텍스트 선택 방지 */
  .clo-noselect { user-select: none !important; }

  /* 패널 고정 및 리사이즈 핸들(바깥) */
  #selPanel{
    position:fixed !important;
    min-width:360px; min-height:220px;
    z-index:6000; transform:translateZ(0);
  }
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel.dragging .edge{pointer-events:none}

  /* 안쪽 얇은 리사이즈 그립(핸들 맞추기 어렵다는 피드백 반영) */
  #selPanel .grip{position:absolute;background:transparent;pointer-events:auto}
  #selPanel .g-left{left:0; top:0; width:8px; height:100%; cursor:ew-resize}
  #selPanel .g-right{right:0; top:0; width:8px; height:100%; cursor:ew-resize}
  #selPanel .g-top{top:0; left:0; height:8px; width:100%; cursor:ns-resize}
  #selPanel .g-bottom{bottom:0; left:0; height:8px; width:100%; cursor:ns-resize}

  /* 지도 차단 실드 */
  #mapShield{position:fixed; inset:0; display:none; background:transparent; z-index:5999}

<!-- Styles from NEW_WORLD_MAP_with_navigation.html -->

  /* 색 변수 (라이트/다크 공통 토큰) */
  :root{
    --ui-bg: #ffffff; --ui-fg:#111827; --ui-muted:#6b7280; --ui-border:#e5e7eb;
    --ui-bg-soft:#f8fafc;
    --brand:#2563eb; --brand-2:#1d4ed8;
    --okay:#16a34a; --warn:#d97706; --danger:#dc2626;
    --ring: 0 0 0 3px rgba(37,99,235,.25);
  }
  body.dark{
    --ui-bg:#0f172a; --ui-fg:#e5e7eb; --ui-muted:#9ca3af; --ui-border:#243041;
    --ui-bg-soft:#111827;
    --brand:#60a5fa; --brand-2:#3b82f6;
    --okay:#34d399; --warn:#f59e0b; --danger:#f87171;
    --ring: 0 0 0 3px rgba(96,165,250,.25);
  }

  /* 패널: 드래그 앤 드롭을 고정 사이즈로 제한 */
  #selPanel{
    position:fixed !important; right:16px; bottom:90px;
    width:640px !important; height:480px !important;
    max-width:80vw !important; max-height:70vh !important;
    z-index:6000; background:var(--ui-bg); color:var(--ui-fg);
    border:1px solid var(--ui-border);
    box-shadow:0 8px 24px rgba(0,0,0,.10);
    border-radius:12px; overflow:visible !important;
  }
  /* 엣지 핸들 영역(표 조작과 충돌 안나게 바깥쪽에 배치) */
  #selPanel .edge{position:absolute;background:transparent}
  #selPanel .e-left{left:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-right{right:-16px; top:0; width:22px; height:100%; cursor:ew-resize}
  #selPanel .e-top{top:-20px; left:0; width:100%; height:24px; cursor:ns-resize}
  #selPanel .e-bottom{bottom:-16px; left:0; width:100%; height:22px; cursor:ns-resize}
  #selPanel .head{
    background:var(--ui-bg-soft); border-bottom:2px solid var(--ui-border);
    border-top-left-radius:12px; border-top-right-radius:12px;
  }

  /* 버튼 리뉴얼(라이트/다크 대응) */
  #selPanel .btn,
  #selPanel button{
    appearance:none; border:1px solid transparent;
    background:var(--ui-bg); color:var(--ui-fg);
    padding:8px 12px; border-radius:10px; font-weight:700;
    line-height:1; cursor:pointer; transition:.15s;
    box-shadow:0 1px 0 rgba(0,0,0,.06);
  }
  /* 각각의 성격 */
  #btnClearSel{ /* 표 비우기 = 경고성 */
    background:linear-gradient(0deg, rgba(249,115,22,.08), rgba(249,115,22,.08));
    border-color:rgba(249,115,22,.25); color:var(--warn);
  }
  #btnCopyTSV{   /* 보조 = 중립 */
    background:linear-gradient(0deg, rgba(107,114,128,.08), rgba(107,114,128,.08));
    border-color:rgba(107,114,128,.25); color:var(--ui-fg);
  }
  #btnSaveXLSX{  /* 주요 = 브랜드 */
    background:linear-gradient(180deg, var(--brand), var(--brand-2));
    color:#fff; border-color:transparent; box-shadow:0 2px 10px rgba(37,99,235,.25);
  }
  /* Hover/Active/Focus */
  #selPanel .btn:hover{ filter:brightness(1.03); transform:translateY(-1px) }
  #selPanel .btn:active{ transform:translateY(0) }
  #selPanel .btn:focus-visible{ outline:none; box-shadow:var(--ring) }

  /* 우측 Del 아이콘 일관화 */
  #selPanel .row-actions .btn-del{
    display:inline-flex; align-items:center; justify-content:center;
    width:28px; height:28px; border-radius:8px;
    background:transparent; border:1px solid var(--ui-border);
    transition:.15s; cursor:pointer;
  }
  #selPanel .row-actions .btn-del:hover{
    background:rgba(220,38,38,.08); border-color:rgba(220,38,38,.35); color:var(--danger);
  }
  
  /* 길찾기 버튼 스타일 */
  #selPanel .row-actions .btn-nav{
    display:inline-flex; align-items:center; justify-content:center;
    width:28px; height:28px; border-radius:8px; margin-left:4px;
    background:transparent; border:1px solid var(--ui-border);
    transition:.15s; cursor:pointer;
    font-size:14px;
  }
  #selPanel .row-actions .btn-nav:hover{
    background:rgba(59,130,246,.08); border-color:rgba(59,130,246,.35); color:var(--c-sky);
  }

  /* 경로 순번 인풋 톤 맞춤 */
  #selPanel input.routeOrder{
    height:28px; border:1px solid var(--ui-border); border-radius:8px;
    padding:0 8px; background:var(--ui-bg); color:var(--ui-fg);
  }
  #selPanel input.routeOrder:focus{ outline:none; box-shadow:var(--ring); border-color:var(--brand) }

  /* 내부 스크롤 컨테이너 상한 해제 */
  #selPanel > div[style*="max-height"]{ max-height:none !important; height:auto !important }

  /* Allow unlimited resizing with constraints to keep panel header accessible */
  #selPanel{ 
    resize:both !important; 
    overflow:auto !important;
    /* Remove size limits for unlimited resizing */
    min-width: 200px !important;
    min-height: 100px !important;
    max-width: none !important;
    max-height: none !important;
  }
</style>
<!-- Leaflet CSS -->
<link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" id="leaflet-css" rel="stylesheet"/>
</head>
<body>
<!-- Performance Monitor -->
<div class="perf-monitor" id="perfMonitor">
  FPS: <span id="fps">0</span> | 
  Memory: <span id="memory">0MB</span>
</div>
<!-- Mobile Overlay -->
<div class="mobile-overlay" id="mobileOverlay"></div>
<div id="app">
<!-- 📱 LEFT RAIL - 모바일 친화적 네비게이션 -->
<aside id="rail">
<div aria-label="CLUSTRO 로고" class="logo-box" title="CLUSTRO v12.2 - Final Secured Edition">
<svg aria-label="CLUSTRO logo" viewbox="0 0 64 64">
<defs>
<lineargradient id="g" x1="0" x2="1" y1="0" y2="1">
<stop offset="0" stop-color="#0EA5E9"></stop>
<stop offset="1" stop-color="#1F3A8A"></stop>
</lineargradient>
</defs>
<circle cx="32" cy="32" fill="url(#g)" r="28" stroke="#0b2540" stroke-width="2"></circle>
<circle cx="22" cy="22" fill="#fff" r="4"></circle>
<circle cx="42" cy="22" fill="#fff" r="4"></circle>
<circle cx="22" cy="42" fill="#fff" r="4"></circle>
<circle cx="42" cy="42" fill="#fff" r="4"></circle>
<path d="M22 22 L42 42 M42 22 L22 42" stroke="#fff" stroke-width="2"></path>
</svg>
</div>
<button aria-label="데이터 관리" class="icbtn" data-target="#secData" role="tab" title="데이터 관리">
<svg aria-hidden="true" viewbox="0 0 24 24">
<path d="M3 7h18M3 12h18M3 17h18"></path>
<circle cx="7" cy="7" r="1"></circle>
<circle cx="11" cy="12" r="1"></circle>
<circle cx="15" cy="17" r="1"></circle>
</svg>
<span>데이터</span>
</button>
<button aria-label="필터 설정" class="icbtn" data-target="#secFilter" role="tab" title="필터 설정">
<svg aria-hidden="true" viewbox="0 0 24 24">
<path d="M3 5h18l-7 8v5l-4 2v-7z"></path>
</svg>
<span>필터</span>
</button>
<button aria-label="지도 설정" class="icbtn" data-target="#secMap" role="tab" title="지도 설정">
<svg aria-hidden="true" viewbox="0 0 24 24">
<path d="M3 6l7-3 7 3 4-2v16l-7 3-7-3-4 2V6zM10 3v16M17 6v15M3 6v14"></path>
</svg>
<span>지도</span>
</button>
<button aria-label="경로 계획" class="icbtn" data-target="#secRoute" role="tab" title="경로 계획">
<svg aria-hidden="true" viewbox="0 0 24 24">
<path d="M4 6h6l2 4h8M4 18h10l2-4h4"></path>
</svg>
<span>경로</span>
</button>
<button aria-label="출력 설정" class="icbtn" data-target="#secPrint" role="tab" title="출력 설정">
<svg aria-hidden="true" viewbox="0 0 24 24">
<path d="M6 9V3h12v6M6 14h12v7H6z"></path>
<rect height="7" rx="2" width="18" x="3" y="9"></rect>
</svg>
<span>출력</span>
</button>
<div style="margin-top:auto;font-size:11px;color:#9ca3af;text-align:center;">
<div>v12.2</div>
<div style="font-size:9px;">🔒 Secured</div>
</div>
</aside>
<!-- 🔧 TOOLBAR - 반응형 도구모음 -->
<header id="toolbar" role="banner">
<button aria-label="메뉴 열기" class="btn btn-sky mobile-menu-btn" id="mobileMenuBtn" style="display:none;">
<svg fill="none" height="18" stroke="currentColor" stroke-width="2" viewbox="0 0 24 24" width="18">
<line x1="3" x2="21" y1="6" y2="6"></line>
<line x1="3" x2="21" y1="12" y2="12"></line>
<line x1="3" x2="21" y1="18" y2="18"></line>
</svg>
      메뉴
    </button>
<div class="badge ok">
<svg fill="none" height="14" stroke="currentColor" stroke-width="2" viewbox="0 0 24 24" width="14">
<path d="M9 12l2 2 4-4"></path>
<circle cx="12" cy="12" r="9"></circle>
</svg>
      보안 강화됨
    </div>
<div class="badge" id="statusBadge">
<span id="statusText">준비됨</span>
</div>
<div class="row" style="margin-left: auto;">
<button class="btn btn-outline btn-util" id="perfToggle" title="성능 모니터 토글">
        📊 성능
      </button>
<button class="btn btn-outline btn-util" id="themeToggle" title="다크 모드 토글">
        🌙 테마
      </button>
</div>
</header>
<!-- 📋 LEFT SIDEBAR - 향상된 UI/UX -->
<nav aria-label="메인 네비게이션" id="lhs" role="navigation">
<!-- 📊 DATA SECTION -->
<section class="sec active" id="secData">
<details open="">
<summary aria-expanded="true" role="button">
<span>📊 데이터 로드</span>
</summary>
<div class="card">
<div class="row">
<label class="form-control" for="fileInput" style="cursor: pointer; text-align: center;">
<input accept=".xlsx,.csv,.json" aria-describedby="fileHelp" id="fileInput" style="display: none;" type="file"/>
              📁 파일 선택
            </label>
</div>
<div class="small" id="fileHelp" style="margin-top: 4px;">
            Excel(.xlsx), CSV, JSON 파일 지원 (최대 10MB)
          </div>
<div class="progress-bar" id="loadProgress" style="margin-top: 8px; display: none;">
<div class="progress-fill" id="progressFill"></div>
</div>
</div>
</details>
<details id="adv" style="display:none">
<summary aria-expanded="false" role="button">
<span>⚙️ 고급 설정</span>
</summary>
<div class="card">
<div class="row">
<label for="sheet">시트:</label>
<select aria-label="시트 선택" class="form-control" id="sheet"></select>
</div>
<div class="row">
<label for="latCol">위도 열:</label>
<input aria-label="위도 컬럼" class="form-control" id="latCol" type="text" value="R"/>
</div>
<div class="row">
<label for="lngCol">경도 열:</label>
<input aria-label="경도 컬럼" class="form-control" id="lngCol" type="text" value="S"/>
</div>
<button class="btn btn-primary" onclick="safeOperation('toRowsManual')">적용</button>
</div>
</details>
<details>
<summary aria-expanded="false" role="button">
<span>📈 데이터 현황</span>
</summary>
<div class="card">
<div class="row">
<span class="badge" id="totalBadge">전체: 0</span>
<span class="badge ok" id="validBadge">유효: 0</span>
<span class="badge warn" id="errorBadge">오류: 0</span>
</div>
</div>
</details>
</section>
<!-- 🔍 FILTER SECTION -->
<section class="sec" id="secFilter">
<details>
<summary aria-expanded="false" role="button">
<span>🔍 검색 필터</span>
</summary>
<div class="card">
<div class="row">
<input aria-label="검색어 입력" autocomplete="off" class="form-control" id="scopeInput" placeholder="읍면동 또는 군집번호 검색..." type="search"/>
<button class="btn btn-sky" onclick="safeOperation('applyScope')">
              검색
            </button>
</div>
</div>
</details>
<details>
<summary aria-expanded="false" role="button">
<span>🏘️ 읍면동별</span>
</summary>
<div class="card">
<div aria-label="읍면동 필터" class="chips" id="emdBox" role="group"></div>
</div>
</details>
<details>
<summary aria-expanded="false" role="button">
<span>👥 군집별</span>
</summary>
<div class="card">
<div aria-label="군집 필터" class="chips" id="grpBox" role="group"></div>
</div>
</details>
</section>
<!-- 🗺️ MAP SECTION -->
<section class="sec" id="secMap">
<details>
<summary aria-expanded="false" role="button">
<span>🗺️ 지도 설정</span>
</summary>
<div class="card">
<div class="row">
<label for="baseSelect">배경:</label>
<select aria-label="배경지도 선택" class="form-control" id="baseSelect">
<option value="osm">OpenStreetMap</option>
<option selected="" value="vworld_base">VWorld 기본</option>
<option value="vworld_satellite">VWorld 위성</option>
<option value="google_roadmap">Google 도로</option>
<option value="google_satellite">Google 위성</option>
</select>
</div>
<div class="row" style="margin-top: 12px;">
<label>
<input checked="" id="clusterToggle" type="checkbox"/> 
              마커 클러스터링
            </label>
</div>
<div class="row">
<label>마커 스타일:</label>
<select aria-label="마커 스타일 선택" class="form-control" id="markerStyle">
<option value="circle">원형</option>
<option value="tag">태그</option>
<option selected="" value="bubble">말풍선</option>
</select>
</div>
</div>
</details>
<details>
<summary aria-expanded="false" role="button">
<span>🎨 표시 옵션</span>
</summary>
<div class="card">
<div class="row">
<label>
<input id="bwToggle" type="checkbox"/> 
              흑백 모드
            </label>
</div>
<div class="row">
<label for="fontSizeRange">폰트 크기:</label>
<input aria-label="폰트 크기 조절" class="form-control" id="fontSizeRange" max="18" min="10" type="range" value="14"/>
<span id="fontSizeValue">14px</span>
</div>
<div class="row">
<label for="markerSizeRange">마커 크기:</label>
<input aria-label="마커 크기 조절" class="form-control" id="markerSizeRange" max="50" min="20" type="range" value="30"/>
<span id="markerSizeValue">30px</span>
</div>
</div>
</details>
</section>
<!-- 🛣️ ROUTE SECTION -->
<section class="sec" id="secRoute">
<details>
<summary aria-expanded="false" role="button">
<span>🛣️ 경로 계획</span>
</summary>
<div class="card">
<div class="row">
<label for="dailyMax">일일 최대:</label>
<input aria-label="일일 최대 방문 수" class="form-control" id="dailyMax" max="100" min="1" type="number" value="15"/>
</div>
<button class="btn btn-accent" onclick="safeOperation('optimizeRoute')">
            🎯 경로 최적화
          </button>
<div class="small" style="margin-top: 8px;">
            선택된 항목들을 기반으로 최적 경로를 계산합니다.
          </div>
</div>
</details>
<details>
<summary aria-expanded="false" role="button">
<span>📋 선택 관리</span>
</summary>
<div class="card">
<button class="btn btn-sky" onclick="safeOperation('showSelectionPanel')">
            📋 선택 목록 보기
          </button>
<button class="btn btn-util" onclick="safeOperation('clearSelection')">
            🗑️ 선택 초기화
          </button>
<div class="small" id="selectionStats" style="margin-top: 8px;">
            선택된 항목: <span id="selectedCount">0</span>개
          </div>
</div>
</details>
</section>
<!-- 🖨️ PRINT SECTION -->
<section class="sec" id="secPrint">
<details>
<summary aria-expanded="false" role="button">
<span>🖨️ 출력 설정</span>
</summary>
<div class="card">
<div class="row">
<button class="btn btn-primary" onclick="safeOperation('exportExcel')">
              📊 Excel 내보내기
            </button>
</div>
<div class="row">
<button class="btn btn-accent" onclick="safeOperation('exportPDF')">
              📄 PDF 내보내기
            </button>
</div>
<div class="row">
<button class="btn btn-util" onclick="window.print()">
              🖨️ 인쇄하기
            </button>
</div>
</div>
</details>
</section>
</nav>
<!-- 📏 RESIZER -->
<div aria-label="패널 크기 조절" id="gut" role="separator" tabindex="0" title="패널 크기 조절"></div>
<!-- 🗺️ MAP CONTAINER -->
<main id="rhs" role="main">
<div aria-label="인터랙티브 지도" id="map"></div>
<!-- MAP CONTROLS -->
<div class="map-bottom">
<div class="toolbar-map">
<button class="btn btn-sky" onclick="safeOperation('centerMap')" title="지도 중심 이동">
          🎯 중심
        </button>
<button class="btn btn-primary" onclick="safeOperation('fitBounds')" title="전체 보기">
          🔍 전체
        </button>
<button class="btn btn-accent" onclick="safeOperation('showStatistics')" title="통계 보기">
          📊 통계
        </button>
</div>
</div>
<!-- WATERMARK -->
<div class="wm" id="wm">CLUSTRO v12.2 Final Secured</div>
</main>
</div>
<!-- 📋 SELECTION PANEL -->
<div aria-hidden="true" aria-labelledby="selPanelTitle" class="panel" id="selPanel" role="dialog">
<div class="head">
<h4 id="selPanelTitle">📋 선택된 항목</h4>
<button aria-label="패널 닫기" class="btn btn-util" onclick="safeOperation('hideSelectionPanel')">
      ✕
    </button>
</div>
<div class="body">
<div style="padding: 8px;">
<button class="btn btn-accent" onclick="safeOperation('clearSelection')" style="margin-bottom: 8px;">
        🗑️ 전체 삭제
      </button>
</div>
<table aria-label="선택된 항목 목록" role="table">
<thead>
<tr>
<th scope="col">ID</th>
<th scope="col">시설명</th>
<th scope="col">주소</th>
<th class="row-actions" scope="col">삭제</th>
</tr>
</thead>
<tbody id="selBody"></tbody>
</table>
</div>
</div>
<!-- 🔧 EXTERNAL SCRIPTS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<!-- 🚀 MAIN APPLICATION SCRIPT -->
<script>
'use strict';

/**
 * 🔒 SECURITY & UTILITY MODULE
 * 보안 기능과 유틸리티 함수들을 중앙 집중 관리
 */
const SecurityUtils = {
  // HTML 이스케이프 - XSS 방지
  escapeHtml(unsafe) {
    if (unsafe == null) return '';
    return String(unsafe)
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  },

  // 입력값 검증 및 정제
  validateInput(input, type = 'text', maxLength = 1000) {
    if (input == null) return '';
    
    input = String(input).trim();
    
    // 길이 제한
    if (input.length > maxLength) {
      input = input.substring(0, maxLength);
    }
    
    switch(type) {
      case 'number':
        return input.replace(/[^\d.-]/g, '');
      case 'alphanumeric':
        return input.replace(/[^a-zA-Z0-9가-힣\s\-_]/g, '');
      case 'filename':
        return input.replace(/[<>:"/\\|?*]/g, '');
      case 'coordinate':
        return input.replace(/[^\d.-]/g, '');
      default:
        // 기본 XSS 방지
        return input.replace(/<script[^>]*>.*?<\/script>/gi, '')
                   .replace(/javascript:/gi, '')
                   .replace(/on\w+\s*=/gi, '')
                   .replace(/<iframe[^>]*>.*?<\/iframe>/gi, '');
    }
  },

  // 안전한 DOM 조작
  setTextContent(element, text) {
    if (!element) return;
    element.textContent = this.validateInput(text);
  },

  // 파일 검증
  validateFile(file) {
    const errors = [];
    const MAX_SIZE = 10 * 1024 * 1024; // 10MB
    const ALLOWED_TYPES = ['.xlsx', '.csv', '.json'];
    
    if (!file) {
      errors.push('파일이 선택되지 않았습니다.');
      return errors;
    }
    
    if (file.size > MAX_SIZE) {
      errors.push(`파일 크기가 너무 큽니다. (최대: ${MAX_SIZE/1024/1024}MB)`);
    }
    
    const fileExt = '.' + file.name.split('.').pop().toLowerCase();
    if (!ALLOWED_TYPES.includes(fileExt)) {
      errors.push(`허용되지 않는 파일 형식입니다. (허용: ${ALLOWED_TYPES.join(', ')})`);
    }
    
    if (!/^[a-zA-Z0-9가-힣._\s\-()]+$/.test(file.name)) {
      errors.push('파일명에 허용되지 않는 문자가 포함되어 있습니다.');
    }
    
    return errors;
  },

  // CSRF 토큰 생성
  generateCSRFToken() {
    return Array.from(crypto.getRandomValues(new Uint8Array(16)))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
};

/**
 * 🎯 PERFORMANCE MONITOR
 * 성능 모니터링 및 최적화 관리
 */
const PerformanceMonitor = {
  frameCount: 0,
  lastTime: 0,
  
  init() {
    this.startFPSMonitor();
    this.monitorMemory();
  },
  
  startFPSMonitor() {
    const updateFPS = (currentTime) => {
      this.frameCount++;
      
      if (currentTime - this.lastTime >= 1000) {
        const fps = Math.round(this.frameCount * 1000 / (currentTime - this.lastTime));
        const fpsElement = document.getElementById('fps');
        if (fpsElement) fpsElement.textContent = fps;
        
        this.frameCount = 0;
        this.lastTime = currentTime;
      }
      
      requestAnimationFrame(updateFPS);
    };
    
    requestAnimationFrame(updateFPS);
  },
  
  monitorMemory() {
    if ('memory' in performance) {
      setInterval(() => {
        const memMB = Math.round(performance.memory.usedJSHeapSize / 1048576);
        const memElement = document.getElementById('memory');
        if (memElement) memElement.textContent = `${memMB}MB`;
      }, 1000);
    }
  }
};

/**
 * 🔔 NOTIFICATION SYSTEM
 * 사용자 경험 향상을 위한 알림 시스템
 */
const NotificationSystem = {
  show(message, type = 'success', duration = 3000) {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    
    // 아이콘 추가
    const icons = {
      success: '✅',
      warning: '⚠️',
      error: '❌',
      info: 'ℹ️'
    };
    
    notification.innerHTML = `
      <span>${icons[type] || '📌'}</span>
      <span>${SecurityUtils.escapeHtml(message)}</span>
    `;
    
    document.body.appendChild(notification);
    
    // 애니메이션 시작
    setTimeout(() => notification.classList.add('show'), 100);
    
    // 자동 제거
    setTimeout(() => {
      notification.classList.remove('show');
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 250);
    }, duration);
  }
};

/**
 * 🔄 ERROR HANDLER
 * 전역 오류 처리 및 복구 시스템
 */
const ErrorHandler = {
  init() {
    window.addEventListener('error', this.handleError.bind(this));
    window.addEventListener('unhandledrejection', this.handlePromiseError.bind(this));
  },
  
  handleError(event) {
    console.error('전역 오류:', event.error);
    
    const errorInfo = {
      message: event.error?.message || '알 수 없는 오류',
      filename: event.filename || '알 수 없는 파일',
      line: event.lineno || 0,
      column: event.colno || 0
    };
    
    this.logError(errorInfo);
    this.showUserFriendlyError(errorInfo.message);
    
    // 복구 시도
    this.attemptRecovery();
  },
  
  handlePromiseError(event) {
    console.error('처리되지 않은 Promise 오류:', event.reason);
    this.logError({
      message: event.reason?.message || '비동기 작업 오류',
      type: 'promise'
    });
    
    this.showUserFriendlyError('비동기 작업 중 오류가 발생했습니다.');
  },
  
  logError(errorInfo) {
    // 로컬 스토리지에 오류 로그 저장 (개발/디버깅 용)
    try {
      const errorLog = JSON.parse(localStorage.getItem('errorLog') || '[]');
      errorLog.push({
        ...errorInfo,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href
      });
      
      // 최대 50개 로그만 유지
      if (errorLog.length > 50) {
        errorLog.splice(0, errorLog.length - 50);
      }
      
      localStorage.setItem('errorLog', JSON.stringify(errorLog));
    } catch (e) {
      console.warn('오류 로그 저장 실패:', e);
    }
  },
  
  showUserFriendlyError(message) {
    const userMessage = this.getUserFriendlyMessage(message);
    NotificationSystem.show(userMessage, 'error', 5000);
  },
  
  getUserFriendlyMessage(technicalMessage) {
    const friendlyMessages = {
      'fetch': '네트워크 연결을 확인해주세요.',
      'parse': '파일 형식이 올바르지 않습니다.',
      'memory': '메모리가 부족합니다. 페이지를 새로고침해주세요.',
      'permission': '권한이 필요합니다.',
      'quota': '저장 공간이 부족합니다.'
    };
    
    for (const [key, message] of Object.entries(friendlyMessages)) {
      if (technicalMessage.toLowerCase().includes(key)) {
        return message;
      }
    }
    
    return '일시적인 오류가 발생했습니다. 잠시 후 다시 시도해주세요.';
  },
  
  attemptRecovery() {
    // 기본적인 복구 시도
    setTimeout(() => {
      if (window.myMap && !document.getElementById('map').hasChildNodes()) {
        console.log('지도 복구 시도...');
        initializeMap();
      }
    }, 1000);
  }
};

/**
 * 📱 RESPONSIVE HANDLER
 * 반응형 디자인 및 모바일 지원
 */
const ResponsiveHandler = {
  isMobile: false,
  
  init() {
    this.checkDevice();
    this.setupMobileMenu();
    this.setupResizeListener();
  },
  
  checkDevice() {
    this.isMobile = window.innerWidth <= 768;
    document.body.classList.toggle('mobile', this.isMobile);
    
    // 모바일 메뉴 버튼 표시/숨김
    const mobileMenuBtn = document.getElementById('mobileMenuBtn');
    if (mobileMenuBtn) {
      mobileMenuBtn.style.display = this.isMobile ? 'flex' : 'none';
    }
  },
  
  setupMobileMenu() {
    const mobileMenuBtn = document.getElementById('mobileMenuBtn');
    const mobileOverlay = document.getElementById('mobileOverlay');
    const lhs = document.getElementById('lhs');
    
    if (mobileMenuBtn && mobileOverlay && lhs) {
      mobileMenuBtn.addEventListener('click', () => {
        lhs.classList.add('mobile-open');
        mobileOverlay.classList.add('show');
      });
      
      mobileOverlay.addEventListener('click', () => {
        lhs.classList.remove('mobile-open');
        mobileOverlay.classList.remove('show');
      });
    }
  },
  
  setupResizeListener() {
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        this.checkDevice();
        if (window.myMap) {
          window.myMap.invalidateSize();
        }
      }, 250);
    });
  }
};

/**
 * 🎨 THEME MANAGER
 * 다크모드 및 테마 관리
 */
const ThemeManager = {
  currentTheme: 'light',
  
  init() {
    this.loadTheme();
    this.setupThemeToggle();
  },
  
  loadTheme() {
    const savedTheme = localStorage.getItem('theme');
    const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
    
    this.currentTheme = savedTheme || (prefersDark ? 'dark' : 'light');
    this.applyTheme(this.currentTheme);
  },
  
  applyTheme(theme) {
    document.body.classList.toggle('auto-dark', theme === 'dark');
    
    const themeToggle = document.getElementById('themeToggle');
    if (themeToggle) {
      themeToggle.textContent = theme === 'dark' ? '☀️ 라이트' : '🌙 다크';
    }
    
    localStorage.setItem('theme', theme);
    this.currentTheme = theme;
  },
  
  setupThemeToggle() {
    const themeToggle = document.getElementById('themeToggle');
    if (themeToggle) {
      themeToggle.addEventListener('click', () => {
        const newTheme = this.currentTheme === 'dark' ? 'light' : 'dark';
        this.applyTheme(newTheme);
      });
    }
  }
};

/**
 * 🗂️ STATE MANAGER
 * 애플리케이션 상태 관리 시스템
 */
const StateManager = {
  state: {
    rows: [],
    rowsById: new Map(),
    selectedIds: new Set(),
    markersById: new Map(),
    filters: {
      emd: new Set(),
      grp: new Set(),
      search: ''
    },
    ui: {
      currentSection: 'secData',
      panelVisible: false
    }
  },
  
  observers: [],
  
  subscribe(observer) {
    this.observers.push(observer);
  },
  
  notify(change) {
    this.observers.forEach(observer => {
      try {
        observer(change);
      } catch (error) {
        console.error('Observer 오류:', error);
      }
    });
  },
  
  setState(updates) {
    const oldState = { ...this.state };
    this.state = { ...this.state, ...updates };
    this.notify({ oldState, newState: this.state, updates });
  },
  
  getState() {
    return { ...this.state };
  }
};

/**
 * 🛡️ SAFE OPERATION WRAPPER
 * 모든 사용자 액션을 안전하게 래핑하는 함수
 */
function safeOperation(operationName, ...args) {
  try {
    // 상태 업데이트
    updateStatus('처리 중...', 'warn');
    
    // 성능 측정 시작
    const startTime = performance.now();
    
    // 실제 작업 실행
    const result = executeOperation(operationName, ...args);
    
    // Promise인 경우 처리
    if (result instanceof Promise) {
      return result
        .then(finalResult => {
          const duration = performance.now() - startTime;
          console.log(`작업 완료: ${operationName} (${duration.toFixed(2)}ms)`);
          updateStatus('완료', 'ok');
          return finalResult;
        })
        .catch(error => {
          console.error(`작업 실패: ${operationName}`, error);
          const userMessage = ErrorHandler.getUserFriendlyMessage(error.message);
          NotificationSystem.show(`작업 실패: ${userMessage}`, 'error');
          updateStatus('오류', 'bad');
          throw error;
        });
    } else {
      const duration = performance.now() - startTime;
      console.log(`작업 완료: ${operationName} (${duration.toFixed(2)}ms)`);
      updateStatus('완료', 'ok');
      return result;
    }
    
  } catch (error) {
    console.error(`작업 중 오류: ${operationName}`, error);
    const userMessage = ErrorHandler.getUserFriendlyMessage(error.message);
    NotificationSystem.show(`작업 오류: ${userMessage}`, 'error');
    updateStatus('오류', 'bad');
    throw error;
  }
}

/**
 * 🎯 OPERATION EXECUTOR
 * 실제 작업을 수행하는 함수들
 */
function executeOperation(operationName, ...args) {
  const operations = {
    // 데이터 관련
    'loadExcel': () => loadExcelFile(),
    'toRowsManual': () => processManualSheetSelection(),
    'applyScope': () => applySearchFilter(),
    
    // 지도 관련
    'centerMap': () => centerMapToData(),
    'fitBounds': () => fitMapToBounds(),
    'optimizeRoute': () => optimizeRouteSelection(),
    
    // 선택 관리
    'showSelectionPanel': () => showSelectionPanel(),
    'hideSelectionPanel': () => hideSelectionPanel(),
    'clearSelection': () => clearAllSelections(),
    
    // 내보내기
    'exportExcel': () => exportToExcel(),
    'exportPDF': () => exportToPDF(),
    
    // 통계
    'showStatistics': () => showStatisticsPanel()
  };
  
  if (operations[operationName]) {
    return operations[operationName](...args);
  } else {
    throw new Error(`알 수 없는 작업: ${operationName}`);
  }
}

/**
 * 📊 STATUS UPDATER
 * 상태 표시 업데이트
 */
function updateStatus(text, type = 'ok') {
  const statusBadge = document.getElementById('statusBadge');
  const statusText = document.getElementById('statusText');
  
  if (statusBadge && statusText) {
    statusBadge.className = `badge ${type}`;
    SecurityUtils.setTextContent(statusText, text);
    
    // 일정 시간 후 기본 상태로 복원
    if (type !== 'ok') {
      setTimeout(() => updateStatus('준비됨'), 3000);
    }
  }
}

/**
 * 📂 FILE OPERATIONS
 * 파일 처리 관련 함수들
 */
async function loadExcelFile() {
  const fileInput = document.getElementById('fileInput');
  const file = fileInput?.files?.[0];
  
  if (!file) {
    throw new Error('파일을 선택해주세요.');
  }
  
  // 파일 검증
  const validationErrors = SecurityUtils.validateFile(file);
  if (validationErrors.length > 0) {
    throw new Error(validationErrors.join('\n'));
  }
  
  // 진행률 표시
  showProgress(0);
  
  try {
    const workbook = await readExcelFile(file);
    
    if (workbook.SheetNames.includes("2025DATA")) {
      const rows = processWorksheet(workbook.Sheets["2025DATA"]);
      await updateDataState(rows);
      NotificationSystem.show(`데이터 로드 완료: ${rows.length}개 행`, 'success');
    } else {
      showAdvancedSettings(workbook);
      NotificationSystem.show('2025DATA 시트를 찾을 수 없어 고급 설정을 엽니다.', 'warning');
    }
    
  } finally {
    hideProgress();
  }
}

function readExcelFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    
    reader.onload = (e) => {
      try {
        const workbook = XLSX.read(new Uint8Array(e.target.result), { type: "array" });
        resolve(workbook);
      } catch (error) {
        reject(new Error(`Excel 파일 파싱 실패: ${error.message}`));
      }
    };
    
    reader.onerror = () => reject(new Error('파일 읽기 실패'));
    reader.readAsArrayBuffer(file);
  });
}

function processWorksheet(worksheet) {
  try {
    const jsonData = XLSX.utils.sheet_to_json(worksheet);
    
    return jsonData.map((row, index) => {
      const processedRow = {
        id: SecurityUtils.validateInput(row['고유번호'] || row['ID'] || index + 1, 'alphanumeric'),
        name: SecurityUtils.validateInput(row['시설명'] || row['name'] || '', 'text'),
        addr: SecurityUtils.validateInput(row['구분주소'] || row['address'] || '', 'text'),
        emd: SecurityUtils.validateInput(row['읍면동'] || row['emd'] || '', 'alphanumeric'),
        grp: SecurityUtils.validateInput(row['군집'] || row['group'] || '', 'number'),
        lat: parseFloat(SecurityUtils.validateInput(row['위도'] || row['lat'] || 0, 'coordinate')),
        lng: parseFloat(SecurityUtils.validateInput(row['경도'] || row['lng'] || 0, 'coordinate'))
      };
      
      // 좌표 유효성 검증
      if (isNaN(processedRow.lat) || isNaN(processedRow.lng) || 
          processedRow.lat === 0 || processedRow.lng === 0) {
        processedRow.valid = false;
      } else {
        processedRow.valid = true;
      }
      
      return processedRow;
    }).filter(row => row.id); // ID가 없는 행 제외
    
  } catch (error) {
    throw new Error(`워크시트 처리 실패: ${error.message}`);
  }
}

async function updateDataState(rows) {
  const validRows = rows.filter(row => row.valid);
  const errorRows = rows.filter(row => !row.valid);
  
  // 상태 업데이트
  StateManager.setState({
    rows: validRows,
    rowsById: new Map(validRows.map(row => [String(row.id), row]))
  });
  
  // UI 업데이트
  updateDataBadges(rows.length, validRows.length, errorRows.length);
  await rebuildFilterBoxes();
  await renderMap();
}

function updateDataBadges(total, valid, error) {
  const totalBadge = document.getElementById('totalBadge');
  const validBadge = document.getElementById('validBadge');
  const errorBadge = document.getElementById('errorBadge');
  
  if (totalBadge) SecurityUtils.setTextContent(totalBadge, `전체: ${total}`);
  if (validBadge) SecurityUtils.setTextContent(validBadge, `유효: ${valid}`);
  if (errorBadge) {
    SecurityUtils.setTextContent(errorBadge, `오류: ${error}`);
    errorBadge.className = error > 0 ? 'badge warn' : 'badge ok';
  }
}

function showProgress(percent) {
  const progressBar = document.getElementById('loadProgress');
  const progressFill = document.getElementById('progressFill');
  
  if (progressBar) progressBar.style.display = 'block';
  if (progressFill) progressFill.style.width = `${percent}%`;
}

function hideProgress() {
  const progressBar = document.getElementById('loadProgress');
  if (progressBar) progressBar.style.display = 'none';
}

/**
 * 🎯 MAP OPERATIONS
 * 지도 관련 기능들
 */
let myMap;
let clusterGroup;
let routeLayer;

async function initializeMap() {
  try {
    const mapContainer = document.getElementById('map');
    if (!mapContainer) throw new Error('지도 컨테이너를 찾을 수 없습니다.');
    
    // 기존 지도 정리
    if (myMap) {
      myMap.remove();
    }
    
    // 지도 초기화
    myMap = L.map('map').setView([36.5, 127.5], 8);
    
    // 기본 타일 레이어
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '© OpenStreetMap contributors'
    }).addTo(myMap);
    
    // 클러스터 그룹 초기화
    clusterGroup = L.markerClusterGroup({
      maxClusterRadius: 50,
      spiderfyOnMaxZoom: true,
      showCoverageOnHover: false
    });
    
    myMap.addLayer(clusterGroup);
    
    // 지도 이벤트 리스너
    myMap.on('zoomend', debounce(updateMapState, 300));
    myMap.on('moveend', debounce(updateMapState, 300));
    
    console.log('지도 초기화 완료');
    
  } catch (error) {
    console.error('지도 초기화 실패:', error);
    throw new Error('지도를 초기화할 수 없습니다.');
  }
}

async function renderMap() {
  if (!myMap) {
    await initializeMap();
  }
  
  const { rows } = StateManager.getState();
  
  // 기존 마커 정리
  clusterGroup.clearLayers();
  
  if (!rows || rows.length === 0) {
    NotificationSystem.show('표시할 데이터가 없습니다.', 'warning');
    return;
  }
  
  // 마커 생성 및 추가
  const markers = rows
    .filter(row => row.valid && row.lat && row.lng)
    .map(row => createMarker(row));
  
  clusterGroup.addLayers(markers);
  
  // 지도 범위 조정
  if (markers.length > 0) {
    const group = new L.featureGroup(markers);
    myMap.fitBounds(group.getBounds(), { padding: [20, 20] });
  }
  
  NotificationSystem.show(`${markers.length}개 마커가 표시되었습니다.`, 'success');
}

function createMarker(row) {
  const marker = L.marker([row.lat, row.lng]);
  
  // 마커 스타일 적용
  const markerStyle = document.getElementById('markerStyle')?.value || 'bubble';
  marker.options.className = `mk mk-${markerStyle}`;
  
  // 팝업 내용 생성 (안전한 HTML)
  const popupContent = `
    <div class="marker-popup">
      <h4>${SecurityUtils.escapeHtml(row.name || '이름 없음')}</h4>
      <p><strong>ID:</strong> ${SecurityUtils.escapeHtml(row.id)}</p>
      <p><strong>주소:</strong> ${SecurityUtils.escapeHtml(row.addr || '주소 없음')}</p>
      <p><strong>읍면동:</strong> ${SecurityUtils.escapeHtml(row.emd || '정보 없음')}</p>
      <p><strong>군집:</strong> ${SecurityUtils.escapeHtml(row.grp || '정보 없음')}</p>
      <div style="margin-top: 8px;">
        <button class="btn btn-sky btn-sm" onclick="safeOperation('selectItem', '${SecurityUtils.escapeHtml(row.id)}')">
          선택
        </button>
        <button class="btn btn-accent btn-sm" onclick="safeOperation('showRoute', '${SecurityUtils.escapeHtml(row.id)}')">
          경로
        </button>
      </div>
    </div>
  `;
  
  marker.bindPopup(popupContent);
  marker.rowData = row;
  
  return marker;
}

function centerMapToData() {
  const { rows } = StateManager.getState();
  const validRows = rows.filter(row => row.valid && row.lat && row.lng);
  
  if (validRows.length === 0) {
    NotificationSystem.show('표시할 데이터가 없습니다.', 'warning');
    return;
  }
  
  // 중심점 계산
  const avgLat = validRows.reduce((sum, row) => sum + row.lat, 0) / validRows.length;
  const avgLng = validRows.reduce((sum, row) => sum + row.lng, 0) / validRows.length;
  
  myMap.setView([avgLat, avgLng], 12);
  NotificationSystem.show('지도 중심을 데이터 위치로 이동했습니다.', 'success');
}

function fitMapToBounds() {
  if (clusterGroup.getLayers().length > 0) {
    myMap.fitBounds(clusterGroup.getBounds(), { padding: [20, 20] });
    NotificationSystem.show('모든 데이터가 보이도록 지도를 조정했습니다.', 'success');
  }
}

function updateMapState() {
  // 지도 상태 변경 시 필요한 업데이트 수행
  const center = myMap.getCenter();
  const zoom = myMap.getZoom();
  
  // 로컬 스토리지에 지도 상태 저장
  try {
    localStorage.setItem('mapState', JSON.stringify({
      lat: center.lat,
      lng: center.lng,
      zoom: zoom,
      timestamp: Date.now()
    }));
  } catch (e) {
    console.warn('지도 상태 저장 실패:', e);
  }
}

/**
 * 🔍 FILTER OPERATIONS
 * 필터링 기능들
 */
async function rebuildFilterBoxes() {
  const { rows } = StateManager.getState();
  
  if (!rows || rows.length === 0) return;
  
  // 읍면동 목록 생성
  const emdValues = [...new Set(rows.map(row => row.emd).filter(Boolean))].sort();
  fillChipBox(document.getElementById('emdBox'), emdValues, 'emd');
  
  // 군집 목록 생성
  const grpValues = [...new Set(rows.map(row => row.grp).filter(Boolean))].sort((a, b) => Number(a) - Number(b));
  fillChipBox(document.getElementById('grpBox'), grpValues, 'grp');
}

function fillChipBox(container, values, name) {
  if (!container || !Array.isArray(values)) return;
  
  // 기존 내용 안전하게 제거
  while (container.firstChild) {
    container.removeChild(container.firstChild);
  }
  
  if (values.length === 0) {
    const emptyDiv = document.createElement('div');
    emptyDiv.className = 'small';
    SecurityUtils.setTextContent(emptyDiv, '해당 항목 없음');
    container.appendChild(emptyDiv);
    return;
  }
  
  values.forEach(value => {
    const safeValue = SecurityUtils.validateInput(value, 'alphanumeric');
    
    const label = document.createElement('label');
    label.className = 'chip';
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.name = name;
    checkbox.value = encodeURIComponent(safeValue);
    checkbox.checked = true;
    checkbox.addEventListener('change', debounce(applyFilters, 300));
    
    const textNode = document.createTextNode(' ' + safeValue);
    
    label.appendChild(checkbox);
    label.appendChild(textNode);
    container.appendChild(label);
  });
}

async function applySearchFilter() {
  const searchInput = document.getElementById('scopeInput');
  const searchTerm = searchInput?.value?.trim() || '';
  
  // 검색어 검증
  const safeTerm = SecurityUtils.validateInput(searchTerm, 'alphanumeric', 100);
  
  if (safeTerm !== searchTerm) {
    NotificationSystem.show('검색어에 허용되지 않는 문자가 포함되어 있습니다.', 'warning');
    searchInput.value = safeTerm;
  }
  
  // 필터 상태 업데이트
  const currentState = StateManager.getState();
  StateManager.setState({
    filters: {
      ...currentState.filters,
      search: safeTerm
    }
  });
  
  await applyFilters();
}

async function applyFilters() {
  const { rows, filters } = StateManager.getState();
  
  if (!rows || rows.length === 0) return;
  
  // 체크된 필터 수집
  const checkedEmd = new Set();
  const checkedGrp = new Set();
  
  document.querySelectorAll('input[name="emd"]:checked').forEach(cb => {
    checkedEmd.add(decodeURIComponent(cb.value));
  });
  
  document.querySelectorAll('input[name="grp"]:checked').forEach(cb => {
    checkedGrp.add(decodeURIComponent(cb.value));
  });
  
  // 필터링 적용
  const filteredRows = rows.filter(row => {
    // 읍면동 필터
    if (checkedEmd.size > 0 && !checkedEmd.has(row.emd)) return false;
    
    // 군집 필터
    if (checkedGrp.size > 0 && !checkedGrp.has(row.grp)) return false;
    
    // 검색 필터
    if (filters.search) {
      const searchLower = filters.search.toLowerCase();
      return (
        row.name?.toLowerCase().includes(searchLower) ||
        row.addr?.toLowerCase().includes(searchLower) ||
        row.emd?.toLowerCase().includes(searchLower)
      );
    }
    
    return true;
  });
  
  // 상태 업데이트
  StateManager.setState({
    rows: filteredRows,
    filters: {
      ...filters,
      emd: checkedEmd,
      grp: checkedGrp
    }
  });
  
  await renderMap();
  
  NotificationSystem.show(`필터 적용: ${filteredRows.length}개 항목`, 'success');
}

/**
 * 🎯 SELECTION OPERATIONS
 * 선택 관리 기능들
 */
function showSelectionPanel() {
  const panel = document.getElementById('selPanel');
  if (panel) {
    panel.style.display = 'block';
    panel.setAttribute('aria-hidden', 'false');
    updateSelectionTable();
  }
}

function hideSelectionPanel() {
  const panel = document.getElementById('selPanel');
  if (panel) {
    panel.style.display = 'none';
    panel.setAttribute('aria-hidden', 'true');
  }
}

function updateSelectionTable() {
  const tbody = document.getElementById('selBody');
  const { selectedIds, rowsById } = StateManager.getState();
  
  if (!tbody) return;
  
  // 기존 내용 제거
  while (tbody.firstChild) {
    tbody.removeChild(tbody.firstChild);
  }
  
  // 선택된 항목들 추가
  selectedIds.forEach(id => {
    const row = rowsById.get(id);
    if (!row) return;
    
    const tr = document.createElement('tr');
    tr.dataset.id = id;
    
    // ID 셀
    const tdId = document.createElement('td');
    SecurityUtils.setTextContent(tdId, row.id);
    
    // 이름 셀
    const tdName = document.createElement('td');
    SecurityUtils.setTextContent(tdName, row.name || '이름 없음');
    
    // 주소 셀
    const tdAddr = document.createElement('td');
    SecurityUtils.setTextContent(tdAddr, row.addr || '주소 없음');
    
    // 삭제 버튼 셀
    const tdAction = document.createElement('td');
    tdAction.className = 'row-actions';
    
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'btn btn-accent btn-sm';
    deleteBtn.textContent = '삭제';
    deleteBtn.onclick = () => safeOperation('removeSelection', id);
    
    tdAction.appendChild(deleteBtn);
    
    tr.appendChild(tdId);
    tr.appendChild(tdName);
    tr.appendChild(tdAddr);
    tr.appendChild(tdAction);
    
    tbody.appendChild(tr);
  });
  
  // 선택 개수 업데이트
  updateSelectionCount();
}

function updateSelectionCount() {
  const { selectedIds } = StateManager.getState();
  const countElement = document.getElementById('selectedCount');
  
  if (countElement) {
    SecurityUtils.setTextContent(countElement, selectedIds.size.toString());
  }
}

function clearAllSelections() {
  StateManager.setState({ selectedIds: new Set() });
  updateSelectionTable();
  NotificationSystem.show('선택이 초기화되었습니다.', 'success');
}

/**
 * 🚀 INITIALIZATION
 * 애플리케이션 초기화
 */
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// DOM 로드 완료 시 초기화
document.addEventListener('DOMContentLoaded', async function() {
  try {
    console.log('🚀 CLUSTRO Final Secured v12.2 초기화 시작...');
    
    // 핵심 시스템 초기화
    ErrorHandler.init();
    PerformanceMonitor.init();
    ResponsiveHandler.init();
    ThemeManager.init();
    
    // UI 이벤트 리스너 설정
    setupEventListeners();
    
    // 지도 초기화
    await initializeMap();
    
    // 성능 모니터 토글 설정
    const perfToggle = document.getElementById('perfToggle');
    if (perfToggle) {
      perfToggle.addEventListener('click', () => {
        const monitor = document.getElementById('perfMonitor');
        if (monitor) {
          monitor.classList.toggle('show');
        }
      });
    }
    
    // 네비게이션 설정
    setupNavigation();
    
    // 상태 관리자 옵저버 등록
    StateManager.subscribe((change) => {
      console.log('상태 변경:', change);
      updateSelectionCount();
    });
    
    console.log('✅ 애플리케이션 초기화 완료');
    NotificationSystem.show('CLUSTRO Final Secured v12.2가 준비되었습니다.', 'success');
    
  } catch (error) {
    console.error('초기화 실패:', error);
    NotificationSystem.show('애플리케이션 초기화에 실패했습니다.', 'error');
  }
});

function setupEventListeners() {
  // 파일 입력 이벤트
  const fileInput = document.getElementById('fileInput');
  if (fileInput) {
    fileInput.addEventListener('change', () => safeOperation('loadExcel'));
  }
  
  // 검색 입력 이벤트
  const searchInput = document.getElementById('scopeInput');
  if (searchInput) {
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        safeOperation('applyScope');
      }
    });
  }
  
  // 폰트 크기 조절
  const fontSizeRange = document.getElementById('fontSizeRange');
  const fontSizeValue = document.getElementById('fontSizeValue');
  if (fontSizeRange && fontSizeValue) {
    fontSizeRange.addEventListener('input', (e) => {
      const size = e.target.value + 'px';
      SecurityUtils.setTextContent(fontSizeValue, size);
      document.documentElement.style.setProperty('--flt-font', size);
      document.documentElement.style.setProperty('--tbl-font', size);
    });
  }
  
  // 마커 크기 조절
  const markerSizeRange = document.getElementById('markerSizeRange');
  const markerSizeValue = document.getElementById('markerSizeValue');
  if (markerSizeRange && markerSizeValue) {
    markerSizeRange.addEventListener('input', (e) => {
      const size = e.target.value + 'px';
      SecurityUtils.setTextContent(markerSizeValue, size);
      document.documentElement.style.setProperty('--mk', size);
    });
  }
}

function setupNavigation() {
  // 네비게이션 버튼 이벤트
  document.querySelectorAll('.icbtn').forEach(btn => {
    btn.addEventListener('click', () => {
      const target = btn.dataset.target;
      if (!target) return;
      
      // 모든 섹션 숨기기
      document.querySelectorAll('.sec').forEach(sec => {
        sec.classList.remove('active');
      });
      
      // 모든 버튼 비활성화
      document.querySelectorAll('.icbtn').forEach(b => {
        b.classList.remove('active');
      });
      
      // 선택된 섹션 표시
      const targetSection = document.querySelector(target);
      if (targetSection) {
        targetSection.classList.add('active');
        btn.classList.add('active');
      }
      
      // 모바일에서 메뉴 닫기
      if (ResponsiveHandler.isMobile) {
        document.getElementById('lhs')?.classList.remove('mobile-open');
        document.getElementById('mobileOverlay')?.classList.remove('show');
      }
    });
  });
}

// 개발 모드에서만 전역 접근 허용
if (typeof window !== 'undefined') {
  window.CLUSTRO = {
    safeOperation,
    SecurityUtils,
    StateManager,
    NotificationSystem,
    version: '12.2 Final Secured'
  };
}

console.log('%c🔒 CLUSTRO Final Secured v12.2', 'color: #0EA5E9; font-weight: bold; font-size: 16px;');
console.log('%c모든 보안 취약점이 해결된 최종 버전입니다.', 'color: #059669;');
</script>
<div id="mapControlsTop" style="position:absolute;top:8px;left:calc(var(--rail-w) + var(--side-w) + var(--gut-w) + 8px);z-index:1000;display:flex;gap:6px;align-items:center"><button class="btn btn-sky" id="btnToggleSelTop" title="선택목록">선택목록</button><button class="btn btn-sky" id="btnFitTop" title="맞춤">맞춤</button><button class="btn btn-sky" id="btnRefreshTop" title="필터적용">필터적용</button><select class="form-control" id="routeMethod"><option selected="selected" value="nn2opt">빠른(최근점+2-opt)</option><option value="nn">최근점</option><option value="cluster">클러스터(지오그리드·Morton+NN)</option><option value="hilbert">힐버트(Hilbert)</option><option value="kmeans">K‑평균(k-means)</option></select><input class="form-control" id="dailyMaxNav" max="999" min="1" style="width:84px" title="하루 최대 포인트" type="number" value="50"/><button class="btn btn-primary" id="btnRouteNav" style="padding:6px 12px;font-size:12px">경로 계산</button><button class="btn btn-util" id="btnRouteClearNav" style="padding:6px 12px;font-size:12px">초기화</button></div><script>
// libs
(async function bootstrap(){
  await loadScriptSeq(()=>window.L, ["https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"]);
  await loadScriptSeq(()=>window.XLSX, ["https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"]);
  await loadScriptSeq(()=>window.html2canvas, ["https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"]);
  await loadScriptSeq(()=>window.jspdf, ["https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"]);
  App.init();
})();

async function loadScriptSeq(check, urls){
  for(const url of urls){
    try{
      await new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src=url;
        s.onload=res;
        s.onerror=rej;
        document.head.appendChild(s);
      });
      // if the library is now available, bail early
      if(check()) return true;
    }catch(e){
      console.warn('Failed to load script:', url, e);
    }
  }
  // At this point none of the URLs produced a working library.
  // Notify the user so they understand why parts of the interface may not work.
  if(!check()){
    // Construct a more detailed message listing the attempted URLs for easier debugging.
    const names = urls.join(', ');
    alert('필수 라이브러리를 불러오지 못했습니다. 네트워크 연결을 확인하거나 로컬로 번들된 스크립트를 사용해 주세요. 시도한 URL: ' + names);
  }
  return check();
}
</script><script>
const App = (function(){
  let wb=null, rows=[], rowsById=new Map();
  let map, groupLayer, routeLayer, baseLayer=null;
  let includeRelax=true, scopeTerm="";
  let tblFont=13, fltFont=13, mk=28;

  const selectedIds=new Set();
  const markersById=new Map();

  let selEmd=new Set();
  let selGrp=new Set();

  let AB=[], abMarkers=[]; // for A/B pick

  // 경로 계산 중인지 여부를 나타내는 플래그. 재귀 호출을 방지하기 위해 사용됩니다.
  let isComputing = false;

  const $=(q,root=document)=>root.querySelector(q);
  const $$=(q,root=document)=>Array.from(root.querySelectorAll(q));
  const setVar=(k,v)=>document.documentElement.style.setProperty(k,v);
  const isBlank=v=>v==null||String(v).trim()===''||String(v).trim().toLowerCase()==='null'||String(v).trim()==='-';
  const A1=a=>a?a.toUpperCase().split('').reduce((n,c)=>n*26+(c.charCodeAt(0)-64),0)-1:-1;

  /* map */
  function setupMap(){
    const KOREA_BOUNDS = L.latLngBounds([33.0,124.0],[39.6,132.5]);
    map = L.map('map',{zoomControl:true, zoomSnap:0.1, zoomDelta:0.1, preferCanvas:true, maxBounds: KOREA_BOUNDS, maxBoundsViscosity: 0.8}).setView([36.635,127.491], 12);
    groupLayer=L.layerGroup().addTo(map);
    routeLayer=L.layerGroup().addTo(map);
    L.control.scale({imperial:false}).addTo(map);

    $('#zoomRange').addEventListener('input', e=>map.setZoom(parseFloat(e.target.value)));
    map.on('zoom', ()=>{const z=map.getZoom().toFixed(1); $('#zoomRange').value=z; $('#zoomVal').textContent=z;});

    $('#baseSelect').value = "vworld_base";
    applyBaseAuto();
  }
  const BASES=[
    {id:'osm',url:'https://tile.openstreetmap.org/{z}/{x}/{y}.png',opt:{maxZoom:19,attribution:'© OpenStreetMap',crossOrigin:true}},
    {id:'vworld_gray',url:'https://xdworld.vworld.kr/2d/gray/202002/service/{z}/{x}/{y}.png',opt:{maxZoom:19,attribution:'© VWorld',crossOrigin:true}},
    {id:'vworld_base',url:'https://xdworld.vworld.kr/2d/Base/service/{z}/{x}/{y}.png',opt:{maxZoom:19,attribution:'© VWorld',crossOrigin:true}},
    {id:'none',url:null,opt:{}}
  ];
  function setNoBase(){ if(baseLayer){map.removeLayer(baseLayer);baseLayer=null;} $('#map').style.background='#f2f2f2'; }
  function tileSample(url){
    const z=Math.round(map.getZoom()), c=map.getCenter();
    const x=Math.floor((c.lng+180)/360*Math.pow(2,z));
    const y=Math.floor((1-Math.log(Math.tan(c.lat*Math.PI/180)+1/Math.cos(c.lat*Math.PI/180))/Math.PI)/2*Math.pow(2,z));
    return url.replace('{z}',z).replace('{x}',x).replace('{y}',y);
  }
  function testTile(url,ms=1600){return new Promise(r=>{if(!url)return r(false);const i=new Image();let done=false;const t=setTimeout(()=>{if(!done){done=true;r(false)}},ms);i.onload=()=>{if(!done){done=true;clearTimeout(t);r(true)}};i.onerror=()=>{if(!done){done=true;clearTimeout(t);r(false)}};i.crossOrigin='anonymous';i.src=tileSample(url);});}
  async function switchBase(id, fallback){
    if(baseLayer){map.removeLayer(baseLayer);baseLayer=null;}
    const cfg=BASES.find(b=>b.id===id)||BASES[0];
    if(!cfg.url){setNoBase();return 'none';}
    const ok=await testTile(cfg.url, 1600);
    if(ok){baseLayer=L.tileLayer(cfg.url,cfg.opt).addTo(map); return cfg.id;}
    if(fallback){
      const order=(cfg.id==='osm')?['vworld_gray','vworld_base','none']:(cfg.id==='vworld_gray')?['vworld_base','none']:(cfg.id==='vworld_base')?['none']:['none'];
      for(const nid of order){ const r=await switchBase(nid,false); if(r) return r; }
    }
    setNoBase(); return 'none';
  }
  async function applyBaseAuto(){
    const v=$('#baseSelect').value;
    if(v==='auto') await switchBase('osm',true);
    else await switchBase(v,false);
  }
  $('#basemap')?.addEventListener('change', e=>{
    const v=e.target.value;
    $('#baseSelect').value = (v==='vworld-gray'?'vworld_gray':v==='vworld-base'?'vworld_base':v);
    applyBaseAuto();
  });
  $('#baseSelect')?.addEventListener('change', applyBaseAuto);

  /* excel */
  function toRows(ws, latCol='R', lngCol='S'){
    const arr=XLSX.utils.sheet_to_json(ws,{header:1,defval:""});
    const B=A1('B'), C=A1('C'), G=A1('G'), H=A1('H'), J=A1('J'), U=A1('U');
    const R=A1(latCol), S=A1(lngCol);
    const out=[];
    for(let i=1;i<arr.length;i++){ const r=arr[i]; if(!r) continue;
      const lat=Number(String(r[R]).replace(/,/g,"")), lng=Number(String(r[S]).replace(/,/g,""));
      out.push({
        id: r[C] ?? i, name: r[G] ?? "", addr: r[B] ?? "",
        grp: r[U] ?? "", emd: r[H] ?? "", date: r[J] ?? "",
        lat: isFinite(lat)?lat:(String(r[R]??"").trim()===""?null:NaN),
        lng: isFinite(lng)?lng:(String(r[S]??"").trim()===""?null:NaN),
      });
    }
    return out;
  }
  async function readFile(f){
    return new Promise((res,rej)=>{
      const fr=new FileReader();
      fr.onload=e=>{
        try{
          wb=XLSX.read(new Uint8Array(e.target.result),{type:"array"});
          if(wb.SheetNames.includes("2025DATA")){
            rows = toRows(wb.Sheets["2025DATA"]);
            rowsById = new Map(rows.map(r=>[String(r.id), r]));
            afterLoad();
          }else{
            $("#adv").style.display='block';
            $("#sheet").innerHTML=wb.SheetNames.map(n=>`<option>${n}</option>`).join("");
            alert("2025DATA 시트를 찾을 수 없어 ‘고급 설정’을 열었습니다.");
          }
          res();
        }catch(err){alert("엑셀 파싱 실패: "+err.message); rej(err);}
      };
      fr.readAsArrayBuffer(f);
    });
  }
  function toRowsManual(){
    const ws=wb.Sheets[$("#sheet").value]; if(!ws){alert("시트를 선택하세요."); return;}
    rows = toRows(ws, ($("#latCol").value||'R'), ($("#lngCol").value||'S'));
    rowsById = new Map(rows.map(r=>[String(r.id), r]));
    afterLoad();
  }
  function afterLoad(){
    selectedIds.clear(); markersById.clear();
    selEmd=new Set(); selGrp=new Set();
    $("#baseSelect").value="vworld_base"; applyBaseAuto();
    updateBadgesBase(); rebuildFilterBoxes(true); render(true);
  }

  /* search/chips */
  function parseSearch(s){
    const tokens=s.trim().split(/\\s+/).filter(Boolean);
    const emdTokens=tokens.filter(t=>/[가-힣]/.test(t));
    const grpTokens=tokens.filter(t=>/^\\d+$/.test(t));
    return {emdTokens, grpTokens};
  }
  function uniq(a){return [...new Set(a.filter(v=>v!==""&&v!=null))].sort((a,b)=>String(a).localeCompare(String(b),'ko'))}
  function fillChipBox(host, values, name, presetSet){
    host.innerHTML = values.length? values.map(v=>{
      const checked = !presetSet || presetSet.size===0 ? 'checked' : (presetSet.has(String(v))?'checked':'');
      return `<label class="chip"><input type="checkbox" name="${name}" value="${encodeURIComponent(String(v))}" ${checked}> ${String(v)}</label>`;
    }).join("") : `<div class="small">해당 항목 없음</div>`;
  }
  function rebuildFilterBoxes(fromLoad=false){
    const {emdTokens, grpTokens} = parseSearch(scopeTerm);
    const base = rows.filter(r=>{
      const hitEmd = !emdTokens.length || emdTokens.some(t=>String(r.emd||"").includes(t) || String(r.addr||"").includes(t));
      const hitGrp = !grpTokens.length || grpTokens.includes(String(r.grp));
      return hitEmd && hitGrp;
    });
    const emdVals = uniq(base.map(r=>r.emd));
    const grpVals = uniq(base.map(r=>r.grp));
    if(fromLoad || (selEmd.size===0 && selGrp.size===0)){
      selEmd = emdTokens.length ? new Set(emdVals.filter(v=>emdTokens.some(t=>String(v).includes(t))).map(String)) : new Set(emdVals.map(String));
      selGrp = grpTokens.length ? new Set(grpTokens.map(String)) : new Set(grpVals.map(String));
    }else{
      selEmd = new Set(emdVals.filter(v=>selEmd.has(String(v))).map(String));
      if(selEmd.size===0 && emdVals.length) selEmd=new Set(emdVals.map(String));
      selGrp = new Set(grpVals.filter(v=>selGrp.has(String(v))).map(String));
      if(selGrp.size===0 && grpVals.length) selGrp=new Set(grpVals.map(String));
    }
    fillChipBox($('#emdChips'), emdVals, "emd", selEmd);
    fillChipBox($('#grpChips'), grpVals, "grp", selGrp);
    refreshToggleStates();
  }
  function refreshToggleStates(){
    const gi=$$('#grpChips input'); const ei=$$('#emdChips input');
    if(gi.length) $('#grpToggle').checked = gi.every(x=>x.checked);
    if(ei.length) $('#emdToggle').checked = ei.every(x=>x.checked);
    $('#grpToggleLbl').textContent = $('#grpToggle').checked ? '전체 선택' : '전체 해제';
    $('#emdToggleLbl').textContent = $('#emdToggle').checked ? '전체 선택' : '전체 해제';
  }

  /* labels/markers */
  function labelFor(r){
    const s=$("#labelSrc").value;
    if(s==='addr') return r.addr||'';
    if(s==='name') return r.name||'';
    return r.id||'';
  }
  function markerHtml(t){
    const k=$("#markerStyle").value;
    if(k==='tag')    return `<div class="mk mk-tag">${t}</div>`;
    if(k==='bubble') return `<div class="mk mk-bubble"><span>${t}</span><i></i></div>`;
    return `<div class="mk mk-circle">${t}</div>`;
  }
  /* 네비게이션 앱 연동 함수 - 플랫폼 자동 감지 및 앱 실행 */
  function openNav(app, lat, lng, name='목적지') {
    // 목적지 이름 URL 인코딩
    const encodedName = encodeURIComponent(name);
    
    // 플랫폼 감지
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    const isIOS = /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream;
    const isAndroid = /android/i.test(userAgent);
    
    let url = '';
    let fallbackUrl = '';
    
    switch(app) {
      case 'kakao':
        // 카카오맵 - 웹 폴백 포함
        url = `kakaomap://route?ep=${lat},${lng}&by=car`;
        fallbackUrl = `http://m.map.kakao.com/scheme/route?ep=${lat},${lng}&by=car`;
        break;
        
      case 'naver':
        // 네이버맵
        url = `nmap://route/car?dlat=${lat}&dlng=${lng}&dname=${encodedName}&appname=com.example.webapp`;
        if (isIOS) {
          fallbackUrl = 'https://apps.apple.com/kr/app/naver-map/id311867728';
        } else {
          fallbackUrl = 'https://play.google.com/store/apps/details?id=com.nhn.android.nmap';
        }
        break;
        
      case 'tmap':
        // 티맵 - 플랫폼별 다른 URL 스킴
        if (isIOS) {
          url = `tmap://route?rGoName=${encodedName}&rGoX=${lng}&rGoY=${lat}`;
          fallbackUrl = 'https://apps.apple.com/kr/app/tmap/id431589174';
        } else {
          url = `tmap://route?referrer=com.skt.Tmap&goalx=${lng}&goaly=${lat}&goalname=${encodedName}`;
          fallbackUrl = 'https://play.google.com/store/apps/details?id=com.skt.tmap.ku';
        }
        break;
        
      case 'google':
        // 구글맵 - 웹 기반, 앱 자동 연동
        url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving`;
        break;
        
      case 'apple':
        // 애플맵 - iOS 전용
        if (isIOS) {
          url = `http://maps.apple.com/?daddr=${lat},${lng}&dirflg=d`;
        } else {
          // Android에서는 구글맵으로 대체
          url = `https://www.google.com/maps/dir/?api=1&destination=${lat},${lng}&travelmode=driving`;
        }
        break;
        
      default:
        console.error('Unknown navigation app:', app);
        return;
    }
    
    // 앱 실행 시도
    if (app === 'google' || (app === 'apple' && !fallbackUrl)) {
      // 웹 기반 앱은 바로 열기
      window.open(url, '_blank');
    } else if (app === 'kakao') {
      // 카카오맵은 웹 폴백 사용
      const iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      document.body.appendChild(iframe);
      iframe.src = url;
      
      // 앱이 없으면 웹 버전으로 이동
      setTimeout(() => {
        document.body.removeChild(iframe);
        window.open(fallbackUrl, '_blank');
      }, 1500);
    } else {
      // 기타 네이티브 앱 실행 시도
      const startTime = Date.now();
      const iframe = document.createElement('iframe');
      iframe.style.display = 'none';
      document.body.appendChild(iframe);
      iframe.src = url;
      
      // 앱이 설치되지 않은 경우 스토어로 이동
      setTimeout(() => {
        const elapsed = Date.now() - startTime;
        document.body.removeChild(iframe);
        
        // 앱이 실행되지 않았다면 스토어로 이동
        if (elapsed < 2000 && fallbackUrl) {
          window.open(fallbackUrl, '_blank');
        }
      }, 1500);
    }
  }
  
  function tooltipHtml(r){return `<div><b>${r.id||''}</b> - ${r.name||''}<br>${r.addr||''} · ${r.emd||''} · ${r.grp||''}</div>`;}
  function popupHtml(r){
    // Popup displays basic info using textContent to avoid HTML injection and includes action buttons.
    // We build a temporary div and assign textContent for each line to mitigate injection risk.
    const wrapper=document.createElement('div'); wrapper.style.fontSize='12px';
    const lines=[
      ['고유번호:', r.id||''],
      ['시설명:',   r.name||''],
      ['구분주소:', r.addr||''],
      ['읍면동:',   (r.emd||'')+ ' · 군집: '+ (r.grp||'')]
    ];
    lines.forEach(([label,value])=>{
      const p=document.createElement('div');
      const b=document.createElement('b'); b.textContent=label;
      const span=document.createElement('span'); span.textContent=' '+value;
      p.appendChild(b); p.appendChild(span);
      wrapper.appendChild(p);
    });
    // 액션 버튼들 - 추가/제거
    const addBtn=document.createElement('button'); addBtn.className='btn btn-sky'; addBtn.setAttribute('data-act','add'); addBtn.textContent='추가';
    const remBtn=document.createElement('button'); remBtn.className='btn btn-accent'; remBtn.setAttribute('data-act','remove'); remBtn.textContent='제거';
    const btnWrap=document.createElement('div'); 
    btnWrap.style.marginTop = '8px';
    btnWrap.appendChild(addBtn); 
    btnWrap.appendChild(document.createTextNode(' ')); 
    btnWrap.appendChild(remBtn);
    wrapper.appendChild(btnWrap);
    
    // 길찾기 버튼들 추가 - 위도/경도가 있는 경우에만
    if(r.lat && r.lng && r.lat !== 0 && r.lng !== 0) {
      const navTitle = document.createElement('div');
      navTitle.style.marginTop = '10px';
      navTitle.style.marginBottom = '4px';
      navTitle.style.fontWeight = 'bold';
      navTitle.textContent = '길찾기:';
      wrapper.appendChild(navTitle);
      
      const navWrap = document.createElement('div');
      navWrap.style.display = 'flex';
      navWrap.style.flexWrap = 'wrap';
      navWrap.style.gap = '4px';
      
      // 네비게이션 앱 버튼들
      const navApps = [
        {id: 'kakao', name: '카카오', color: '#FEE500', textColor: '#000'},
        {id: 'naver', name: '네이버', color: '#03C75A', textColor: '#fff'},
        {id: 'tmap', name: '티맵', color: '#FF0000', textColor: '#fff'},
        {id: 'google', name: '구글', color: '#4285F4', textColor: '#fff'},
        {id: 'apple', name: '애플', color: '#000', textColor: '#fff'}
      ];
      
      navApps.forEach(app => {
        const navBtn = document.createElement('button');
        navBtn.style.padding = '4px 8px';
        navBtn.style.fontSize = '11px';
        navBtn.style.border = 'none';
        navBtn.style.borderRadius = '4px';
        navBtn.style.backgroundColor = app.color;
        navBtn.style.color = app.textColor;
        navBtn.style.cursor = 'pointer';
        navBtn.textContent = app.name;
        navBtn.setAttribute('data-nav', app.id);
        navBtn.setAttribute('data-lat', r.lat);
        navBtn.setAttribute('data-lng', r.lng);
        navBtn.setAttribute('data-name', r.name || r.addr || '목적지');
        navWrap.appendChild(navBtn);
      });
      
      wrapper.appendChild(navWrap);
    }
    return wrapper.outerHTML;
  }

  function applySelectedStyle(id){
    const m=markersById.get(id); if(!m) return;
    const el=m.getElement(); if(!el) return;
    const box=el.firstChild; if(!box) return;
    if(selectedIds.has(id)) box.classList.add('sel'); else box.classList.remove('sel');
  }

  function filtered(){
    const pass = rows.filter(r=>{
      const missing=(r.lat==null||r.lng==null||Number.isNaN(r.lat)||Number.isNaN(r.lng)||r.lat===0||r.lng===0);
      const passCoord = includeRelax || !missing;
      const passGrp = selGrp.size===0 || selGrp.has(String(r.grp));
      const passEmd = selEmd.size===0 || selEmd.has(String(r.emd));
      const passUn  = (!$('#onlyUninspected').checked) || isBlank(r.date);
      return passCoord && passGrp && passEmd && passUn;
    });
    return pass;
  }

  function render(fit){
    groupLayer.clearLayers(); markersById.clear();
    const pts=[];
    for(const r of filtered()){
      if(!isFinite(r.lat) || !isFinite(r.lng) || r.lat===0 || r.lng===0) continue;
      const m=L.marker([r.lat,r.lng],{icon:L.divIcon({html:markerHtml(labelFor(r)),className:"",iconSize:null})});
      m.bindTooltip(tooltipHtml(r),{sticky:true});
      m.bindPopup(popupHtml(r));
      // When the popup opens, wire up the Add/Remove buttons and Navigation buttons.
      m.on('popupopen', e=>{
        const el = e.popup.getElement();
        const addBtn = el.querySelector('[data-act="add"]');
        const remBtn = el.querySelector('[data-act="remove"]');
        if(addBtn) addBtn.onclick = () => {
          // r may be a shallow copy; fetch the canonical record from rowsById if available
          const rec = rowsById.get(String(r.id)) || r;
          addToSel(rec);
          m.closePopup();
        };
        if(remBtn) remBtn.onclick = () => {
          removeFromSel(String(r.id));
          m.closePopup();
        };
        
        // 길찾기 버튼 이벤트 핸들러 추가
        const navBtns = el.querySelectorAll('[data-nav]');
        navBtns.forEach(btn => {
          btn.onclick = () => {
            const app = btn.getAttribute('data-nav');
            const lat = btn.getAttribute('data-lat');
            const lng = btn.getAttribute('data-lng');
            const name = btn.getAttribute('data-name');
            // 네비게이션 함수 호출 - 사용자 액션으로 실행됨
            openNav(app, lat, lng, name);
            m.closePopup();
          };
        });
      });
      m.on('mouseover', ()=>{const el=m.getElement(); if(el) el.firstChild.classList.add('hover');});
      m.on('mouseout',  ()=>{const el=m.getElement(); if(el) el.firstChild.classList.remove('hover');});
      m.addTo(groupLayer); pts.push([r.lat,r.lng]);
      const id=String(r.id); markersById.set(id, m);
      setTimeout(()=>applySelectedStyle(id),0);
    }
    updateBadgesAfter();
    if(fit && pts.length) map.fitBounds(L.latLngBounds(pts).pad(0.2));
  }

  function updateBadgesBase(){
    const t=rows.length, miss=rows.filter(r=>r.lat==null||r.lng==null||Number.isNaN(r.lat)||Number.isNaN(r.lng)||r.lat===0||r.lng===0).length;
    $("#bTotal").textContent=`총: ${t}`; $("#bMissing").textContent=`좌표없음: ${miss}`;
  }
  function updateBadgesAfter(){
    const a=filtered(); const shown=a.filter(r=>isFinite(r.lat)&&isFinite(r.lng)&&r.lat!==0&&r.lng!==0).length;
    $("#bShown").textContent=`표시: ${shown}`; $("#bFiltered").textContent=`필터제외: ${Math.max(0, rows.length - a.length)}`;
  }

  /* selection table */
  function openSel(){ $("#selPanel").style.display='block' }
  function addToSel(r){
    openSel();
    const id=String(r.id);
    if(selectedIds.has(id)) return;
    selectedIds.add(id); applySelectedStyle(id);
    const tr=document.createElement('tr'); tr.draggable=true; tr.dataset.id=id;
    tr.innerHTML=`<td>${r.id||""}</td>
                  <td>${r.name||""}</td>
                  <td>${r.addr||""}</td>
                  <td>${r.grp||""}</td>
                  <td>${isFinite(r.lat)?r.lat:""}</td>
                  <td>${isFinite(r.lng)?r.lng:""}</td>
                  <td><input type="number" class="routeOrder" value="" min="1" style="width:60px"></td>
                  <td class="row-actions">
                    <span class="btn-del">❌</span>
                    ${(r.lat && r.lng && r.lat !== 0 && r.lng !== 0) ? `<span class="btn-nav" data-lat="${r.lat}" data-lng="${r.lng}" data-name="${(r.name || r.addr || '목적지').replace(/"/g, '&quot;')}" title="길찾기">🧭</span>` : ''}
                  </td>`;
    tr.addEventListener('dblclick', ()=>removeRow(tr));
    tr.addEventListener('dragstart', e=>{tr.classList.add('dragging'); e.dataTransfer.setData('text/plain','row');});
    tr.addEventListener('dragend', ()=>tr.classList.remove('dragging'));
    $("#selBody").appendChild(tr);

    // 선택 목록에 추가한 후 일일 최대 포인트 값을 현재 선택된 개수로 갱신하고, 2개 이상일 경우 즉시 경로를 재계산합니다.
    try {
      const rows=document.querySelectorAll('#selBody tr');
      const daily=document.getElementById('dailyMax');
      if(daily){ daily.value = rows.length.toString(); }
      if(rows.length>=2){
        // skip auto-fill during manual addition so existing selections are preserved
        if(!isComputing) computeRoute(true);
      }else{
        // 1개 이하일 때는 기존 경로를 지우고 통계 초기화
        drawRoute([]);
        document.getElementById('routeStat').textContent='거리: - / 시간: -';
      }
    } catch(_){ /* ignore errors */ }
  }

  // Remove a point from the selection table by its id.  This helper searches the
  // table body for a row with a matching data-id attribute and uses removeRow
  // to delete it.  If the id is not found, nothing happens.  After removal
  // computeRoute will be triggered via removeRow.
  function removeFromSel(id){
    const body = document.getElementById('selBody');
    if(!body) return;
    const tr = Array.from(body.querySelectorAll('tr')).find(tr => String(tr.dataset.id) === String(id));
    if(tr) removeRow(tr);
  }
  function removeRow(tr){
    const id=String(tr.dataset.id);
    selectedIds.delete(id);
    applySelectedStyle(id);
    tr.remove();
    // Remaining rows and daily max update
    const remaining = document.querySelectorAll('#selBody tr');
    const daily=document.getElementById('dailyMax');
    if(daily){ daily.value = remaining.length.toString(); }
    // Recompute route if two or more points remain; otherwise clear route and stats
    if(remaining.length >= 2){
      // skip auto-fill during manual removal
      if(!isComputing) computeRoute(true);
    }else{
      drawRoute([]);
      document.getElementById('routeStat').textContent='거리: - / 시간: -';
    }
  }

  // Allow sorting of the selection list by the route order column.  Clicking the
  // route header toggles between ascending and descending numeric order.  After
  // sorting, the route is recomputed (without auto-fill) so the blue polyline
  // remains accurate.
  (function enableRouteSort(){
    const header=document.getElementById('routeHeader');
    if(!header) return;
    let asc=true;
    header.addEventListener('click', ()=>{
      const body=document.getElementById('selBody');
      const rows=Array.from(body.querySelectorAll('tr'));
      rows.sort((a,b)=>{
        const aval=parseInt(a.querySelector('input.routeOrder')?.value||'')||0;
        const bval=parseInt(b.querySelector('input.routeOrder')?.value||'')||0;
        return asc? aval - bval : bval - aval;
      });
      rows.forEach(tr=>body.appendChild(tr));
      asc=!asc;
      // reassign selectedIds order and recompute route without auto-fill
      if(rows.length>=2){
        if(!isComputing) computeRoute(true);
      }
    });
  })();
  $("#selBody").addEventListener('click', e=>{ 
    if(e.target.classList.contains('btn-del')) {
      removeRow(e.target.closest('tr')); 
    } else if(e.target.classList.contains('btn-nav')) {
      // 선택 목록의 길찾기 버튼 클릭 처리 - 드롭다운 메뉴 표시
      const lat = e.target.getAttribute('data-lat');
      const lng = e.target.getAttribute('data-lng');  
      const name = e.target.getAttribute('data-name');
      
      // 기존 드롭다운 제거
      document.querySelectorAll('.nav-dropdown').forEach(el => el.remove());
      
      // 드롭다운 메뉴 생성
      const dropdown = document.createElement('div');
      dropdown.className = 'nav-dropdown';
      dropdown.style.cssText = `
        position: absolute;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 10000;
        padding: 4px;
        min-width: 120px;
      `;
      
      const navApps = [
        {id: 'kakao', name: '카카오', color: '#FEE500', textColor: '#000'},
        {id: 'naver', name: '네이버', color: '#03C75A', textColor: '#fff'},
        {id: 'tmap', name: '티맵', color: '#FF0000', textColor: '#fff'},
        {id: 'google', name: '구글', color: '#4285F4', textColor: '#fff'},
        {id: 'apple', name: '애플', color: '#000', textColor: '#fff'}
      ];
      
      navApps.forEach(app => {
        const btn = document.createElement('button');
        btn.style.cssText = `
          display: block;
          width: 100%;
          padding: 6px 8px;
          margin: 2px 0;
          border: none;
          border-radius: 3px;
          background: ${app.color};
          color: ${app.textColor};
          cursor: pointer;
          font-size: 12px;
        `;
        btn.textContent = app.name;
        btn.onclick = () => {
          openNav(app.id, lat, lng, name);
          dropdown.remove();
        };
        dropdown.appendChild(btn);
      });
      
      // 드롭다운 위치 계산
      const rect = e.target.getBoundingClientRect();
      dropdown.style.left = (rect.left - 60) + 'px';
      dropdown.style.top = (rect.bottom + 5) + 'px';
      
      document.body.appendChild(dropdown);
      
      // 외부 클릭시 드롭다운 닫기
      setTimeout(() => {
        document.addEventListener('click', function closeDropdown(evt) {
          if (!dropdown.contains(evt.target)) {
            dropdown.remove();
            document.removeEventListener('click', closeDropdown);
          }
        });
      }, 0);
    }
  });
  $("#selBody").addEventListener('dragover', e=>{
    e.preventDefault();
    const dragging=$("#selBody tr.dragging");
    const elsib=Array.from($("#selBody").querySelectorAll('tr:not(.dragging)'));
    const after=elsib.reduce((best,ch)=>{const b=ch.getBoundingClientRect(); const o=e.clientY-b.top-b.height/2; return (o<0&&o>best.offset)?{offset:o,element:ch}:best;},{offset:-Infinity}).element;
    if(!after) $("#selBody").appendChild(dragging); else $("#selBody").insertBefore(dragging, after);
  });
  (function colResize(){
    const table=$("#selTable"); const cols=$("#tblCols").children;
    let startX,startW,colIdx,drag=false;
    table.addEventListener('mousedown', e=>{
      if(!e.target.classList.contains('th-resizer')) return;
      colIdx=parseInt(e.target.getAttribute('data-col')); if(isNaN(colIdx)) return;
      drag=true; startX=e.clientX; startW=parseInt(cols[colIdx].style.width)||table.tHead.rows[0].cells[colIdx].offsetWidth;
      document.body.style.cursor='col-resize';
      window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
      e.preventDefault();
    });
    function onMove(e){ if(!drag) return; const w=Math.max(60,startW+(e.clientX-startX)); cols[colIdx].style.width=w+'px'; }
    function onUp(){ drag=false; document.body.style.cursor=''; window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); }
  })();

 /* 패널 가장자리 리사이즈 */
  (function edgeResize(){
    const p = $("#selPanel");
    const minW=360, minH=220;
    let resizing=false, edge='', sx=0, sy=0, sw=0, sh=0;
    function start(e, which){
      resizing=true; edge=which; sx=e.clientX; sy=e.clientY; sw=p.offsetWidth; sh=p.offsetHeight;
      document.body.style.cursor = (which==='left'||which==='right')?'ew-resize':'ns-resize';
      window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);
      e.preventDefault();
    }
    function move(e){
      if(!resizing) return;
      if(edge==='left'){ const dx = sx - e.clientX; p.style.width = Math.max(minW, sw + dx)+'px'; }
      else if(edge==='right'){ const dx = e.clientX - sx; p.style.width = Math.max(minW, sw + dx)+'px'; }
      else if(edge==='top'){ const dy = sy - e.clientY; p.style.height = Math.max(minH, sh + dy)+'px'; }
      else if(edge==='bottom'){ const dy = e.clientY - sy; p.style.height = Math.max(minH, sh + dy)+'px'; }
    }
    function stop(){ resizing=false; edge=''; document.body.style.cursor=''; window.removeEventListener('mousemove', move); window.removeEventListener('mouseup', stop); }
    p.querySelector('.e-left').addEventListener('mousedown', e=>start(e,'left'));
    p.querySelector('.e-right').addEventListener('mousedown', e=>start(e,'right'));
    p.querySelector('.e-top').addEventListener('mousedown', e=>start(e,'top'));
    p.querySelector('.e-bottom').addEventListener('mousedown', e=>start(e,'bottom'));
  })();

  /* 패널 헤더 드래그 이동 + 더블클릭 초기 위치 복원 */
  (function panelDrag(){
    const p = $("#selPanel");
    const head = p.querySelector('.head');
    let dragging=false, sx=0, sy=0, sl=0, st=0;
    head.addEventListener('mousedown', e=>{
      dragging=true;
      const r=p.getBoundingClientRect();
      sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
      p.style.left = r.left+'px'; p.style.top = r.top+'px';
      p.style.right=''; p.style.bottom='';
      document.body.style.userSelect='none';
      e.preventDefault();
    });
    window.addEventListener('mousemove', e=>{
      if(!dragging) return;
      const dx=e.clientX-sx, dy=e.clientY-sy;
      p.style.left=(sl+dx)+'px';
      p.style.top =(st+dy)+'px';
    });
    window.addEventListener('mouseup', ()=>{ if(!dragging) return; dragging=false; document.body.style.userSelect=''; });
    head.addEventListener('dblclick', ()=>{ p.style.width=''; p.style.height=''; p.style.left=''; p.style.top=''; p.style.right='16px'; p.style.bottom='90px'; });
  })();


  /* route drawing */
  function getSelectedPoints(){
    const arr=[];
    $$("#selBody tr").forEach(tr=>{
      const t=Array.from(tr.querySelectorAll('td'));
      const id=(t[0]?.innerText||"").trim();
      const lat=parseFloat(t[4]?.innerText||""); const lng=parseFloat(t[5]?.innerText||"");
      if(isFinite(lat)&&isFinite(lng)) arr.push({id,lat,lng});
    });
    return arr;
  }
  function drawRouteLatLngs(latlngs){
    routeLayer.clearLayers();
    if(latlngs.length>=2){
      L.polyline(latlngs,{color:'#1064e8',weight:3,opacity:0.9}).addTo(routeLayer);
      map.fitBounds(L.latLngBounds(latlngs).pad(0.2));
    }
  }
  function drawRoute(orderIds){
    routeLayer.clearLayers();
    if(!orderIds || orderIds.length<2) return;
    const pts=getSelectedPoints();
    const latlngs=[];
    orderIds.forEach(id=>{
      const pt = pts.find(p=>String(p.id)===String(id));
      if(pt) latlngs.push([pt.lat, pt.lng]);
    });
    drawRouteLatLngs(latlngs);
  }
  /*
   * Compute geodesic distance between two latitude/longitude points using the
   * haversine formula.  Returns the distance in kilometres.  This replaces
   * the previous Euclidean distance approximation (degree squared), which
   * could significantly under‑ or over‑estimate route lengths when points are
   * far apart or near the poles.
   */
  function dist(a,b){
    // Earth radius in kilometres
    const R = 6371;
    const lat1 = a.lat * Math.PI / 180;
    const lat2 = b.lat * Math.PI / 180;
    const dLat = (b.lat - a.lat) * Math.PI / 180;
    const dLng = (b.lng - a.lng) * Math.PI / 180;
    const sinDLat = Math.sin(dLat / 2);
    const sinDLng = Math.sin(dLng / 2);
    const h = sinDLat * sinDLat + Math.cos(lat1) * Math.cos(lat2) * sinDLng * sinDLng;
    return 2 * R * Math.atan2(Math.sqrt(h), Math.sqrt(1 - h));
  }
  function nearestNeighbor(points){
    if(points.length===0) return [];
    const left=[...points]; const order=[];
    let cur=left.shift(); order.push(cur);
    while(left.length){
      let bestIdx=0, bestD=Infinity;
      for(let i=0;i<left.length;i++){ const d=dist(cur,left[i]); if(d<bestD){bestD=d; bestIdx=i;} }
      cur=left.splice(bestIdx,1)[0]; order.push(cur);
    }
    return order;
  }
  function twoOpt(order){
    function total(o){ let s=0; for(let i=0;i<o.length-1;i++) s+=dist(o[i],o[i+1]); return s; }
    let improved=true; let best=order.slice(); let bestCost=total(best);
    while(improved){
      improved=false;
      for(let i=1;i<best.length-2;i++){
        for(let k=i+1;k<best.length-1;k++){
          const newOrder = best.slice(0,i).concat(best.slice(i,k+1).reverse(), best.slice(k+1));
          const c=total(newOrder);
          if(c<bestCost){best=newOrder; bestCost=c; improved=true;}
        }
      }
    }
    return best;
  }

  /*
   * Compute Morton (Z‑order) code for a latitude/longitude pair.  The latitude and
   * longitude are normalised to the range [0,1] and quantised to 15 bits before
   * interleaving.  Higher bit depths yield a more detailed ordering but are
   * unnecessary for a modest number of points.
   */
  function mortonCode(lat, lng){
    const latNorm=(lat+90)/180;
    const lngNorm=(lng+180)/360;
    const latInt=Math.min(32767,Math.max(0,Math.floor(latNorm*32767)));
    const lngInt=Math.min(32767,Math.max(0,Math.floor(lngNorm*32767)));
    let code=0;
    for(let i=0;i<15;i++){
      code |= ((lngInt>>i)&1)<<(2*i);
      code |= ((latInt>>i)&1)<<(2*i+1);
    }
    return code;
  }

  /*
   * Cluster engine: returns an ordered array of points by sorting them via their
   * Morton code and then applying nearest neighbour to refine local continuity.
   */
  function clusterOrder(points){
    if(!points || points.length<=2) return points.slice();
    const sorted=points.slice().sort((a,b)=>mortonCode(a.lat,a.lng)-mortonCode(b.lat,b.lng));
    return nearestNeighbor(sorted);
  }

  /*
   * Hilbert order: compute a Hilbert curve index for each point based on normalized lat/lng.
   * This implementation uses a simple bitwise algorithm to map two 16-bit coordinates into a 32-bit Hilbert index.
   */
  function hilbertIndex(x, y, bits=16){
    let rx, ry;
    let index = 0;
    for(let s=bits-1; s>=0; s--){
      rx = (x >> s) & 1;
      ry = (y >> s) & 1;
      index += (1 << (2*s)) * ((3 * rx) ^ ry);
      // rotate
      if(ry === 0){
        if(rx === 1){
          x = (1 << bits) - 1 - x;
          y = (1 << bits) - 1 - y;
        }
        const tmp = x; x = y; y = tmp;
      }
    }
    return index;
  }

  function hilbertOrder(points){
    if(!points || points.length<=2) return points.slice();
    let minLat=Infinity,maxLat=-Infinity,minLng=Infinity,maxLng=-Infinity;
    for(const p of points){ if(p.lat<minLat) minLat=p.lat; if(p.lat>maxLat) maxLat=p.lat; if(p.lng<minLng) minLng=p.lng; if(p.lng>maxLng) maxLng=p.lng; }
    const factor=(1<<16)-1;
    const arr=points.map(p=>{
      const x=Math.floor(((p.lng-minLng)/(maxLng-minLng+1e-9))*factor);
      const y=Math.floor(((p.lat-minLat)/(maxLat-minLat+1e-9))*factor);
      const h=hilbertIndex(x,y,16);
      return {h,id:p.id, lat:p.lat, lng:p.lng};
    });
    arr.sort((a,b)=>a.h-b.h);
    return arr.map(e=>{ return {id:e.id, lat:e.lat, lng:e.lng}; });
  }

  /*
   * k-means order: cluster points into approximately sqrt(n) clusters.
   */
  function kmeansOrder(points){
    const n=points.length;
    if(n<=2) return points.slice();
    const k=Math.max(1, Math.round(Math.sqrt(n)));
    // initialize centers with first k points
    const centers=points.slice(0,k).map(p=>({lat:p.lat,lng:p.lng}));
    let assignments=new Array(n).fill(0);
    for(let iter=0; iter<5; iter++){
      // assign points to nearest center
      for(let i=0;i<n;i++){
        let best=0; let bestDist=Infinity;
        for(let j=0;j<k;j++){
          const d=dist(points[i], centers[j]);
          if(d<bestDist){ bestDist=d; best=j; }
        }
        assignments[i]=best;
      }
      // recompute centers
      const sumLat=new Array(k).fill(0); const sumLng=new Array(k).fill(0); const count=new Array(k).fill(0);
      for(let i=0;i<n;i++){
        const c=assignments[i]; sumLat[c]+=points[i].lat; sumLng[c]+=points[i].lng; count[c]++;
      }
      for(let j=0;j<k;j++){
        if(count[j]>0){ centers[j].lat=sumLat[j]/count[j]; centers[j].lng=sumLng[j]/count[j]; }
      }
    }
    // cluster arrays
    const clusters=Array.from({length:k},()=>[]);
    for(let i=0;i<n;i++) clusters[assignments[i]].push(points[i]);
    // order clusters by nearest neighbour of centers
    const centerOrder=nearestNeighbor(centers);
    const result=[];
    for(const idx of centerOrder){
      const cl=clusters[idx];
      const seq=nearestNeighbor(cl);
      result.push(...seq);
    }
    return result;
  }

  async function computeRoute(skipAutoFill=false){
    // 이미 계산 중이면 중복 호출을 방지합니다
    if(isComputing) return;
    isComputing = true;
    try{
    // optional auto-fill (only when skipAutoFill is false)
    if(!skipAutoFill && $('#autoFill').checked){
      const candidates = filtered().filter(r=>isFinite(r.lat)&&isFinite(r.lng));
      const max = Math.max(1, parseInt($('#dailyMax').value)||999);
      // overwrite
      $("#selBody").innerHTML=''; selectedIds.clear();
      for(const r of candidates.slice(0,max)){ addToSel(r); }
    }

    const pts=getSelectedPoints(); if(pts.length<2){alert("선택목록에 2개 이상이 필요합니다."); return;}
    const engine=$('#engine').value;
    // If using cluster engine, compute order using Morton code + nearest neighbour and draw route directly
    if(engine==='cluster' || engine==='hilbert' || engine==='kmeans'){
      let order=[];
      let label="";
      if(engine==='cluster'){ order = clusterOrder(pts); label='클러스터'; }
      else if(engine==='hilbert'){ order = hilbertOrder(pts); label='힐버트'; }
      else if(engine==='kmeans'){ order = kmeansOrder(pts); label='K-평균'; }
      // write back route numbers to selection table
      const idToIdx=new Map(order.map((p,i)=>[String(p.id), i+1]));
      $$("#selBody tr").forEach(tr=>{
        const id=(tr.querySelector('td')?.innerText||"").trim();
        const inp=tr.querySelector('input.routeOrder'); if(!inp) return;
        inp.value = idToIdx.get(String(id))||"";
      });
      drawRoute(order.map(p=>p.id));
      // compute distance/time using haversine and display with label
      let totalDist=0;
      for(let i=0;i<order.length-1;i++){
        totalDist += dist(order[i], order[i+1]);
      }
      const km=totalDist;
      const avgSpeed=30;
      const minutes = km / avgSpeed * 60;
      $('#routeStat').textContent = `거리: ${km.toFixed(1)}km / 시간: ${minutes.toFixed(0)}분 (${label})`;
      return;
    }

    if(engine==='osrm'){
      try{
        const server=$('#osrmServer').value.replace(/\/+$/,'');
        const profile=$('#osrmProfile').value;
        // Trip API for order
        const coords=pts.map(p=>`${p.lng},${p.lat}`).join(';');
        const roundtrip = $('#fixEnds').checked ? 'false' : 'true';
        const src = $('#fixEnds').checked ? 'first' : 'any';
        const dst = $('#fixEnds').checked ? 'last' : 'any';
        const url=`${server}/trip/v1/${profile}/${coords}?geometries=geojson&overview=full&roundtrip=${roundtrip}&source=${src}&destination=${dst}`;
        const res=await fetch(url);
        if(!res.ok) throw new Error('OSRM 응답 오류');
        const data=await res.json();
        if(!data.trips || !data.trips.length) throw new Error('경로 없음');
        const trip=data.trips[0];
        const orderIds = trip.waypoints.sort((a,b)=>a.waypoint_index-b.waypoint_index).map(wp=>pts[wp.trips_index??wp.waypoint_index]?.id ?? pts[wp.waypoint_index]?.id);
        drawRoute(orderIds);
        const m=(trip.distance||0)/1000; const t=(trip.duration||0)/60;
        $('#routeStat').textContent=`거리: ${m.toFixed(1)}km / 시간: ${t.toFixed(0)}분 (OSRM)`;
        return;
      }catch(e){
        console.warn('OSRM 실패, 내장 폴백 사용', e);
        $('#routeStat').textContent=`OSRM 실패→내장 폴백`;
        // fallthrough to builtin
      }
    }

    // builtin
    const method=$("#routeMethod").value;
    let order=pts;
    if(method==='cluster'){
      order = clusterOrder(pts);
    }else if(method==='hilbert'){
      order = hilbertOrder(pts);
    }else if(method==='kmeans'){
      order = kmeansOrder(pts);
    }else if(method==='nn'){
      order = nearestNeighbor(pts);
    }else{
      // default to nearest neighbour + 2-opt for "빠른" and other unknown values
      order = twoOpt(nearestNeighbor(pts));
    }
    const idToIdx=new Map(order.map((p,i)=>[String(p.id), i+1]));
    $$("#selBody tr").forEach(tr=>{
      const id=(tr.querySelector('td')?.innerText||"").trim();
      const inp=tr.querySelector('input.routeOrder'); if(!inp) return;
      inp.value = idToIdx.get(String(id))||"";
    });
    drawRoute(order.map(p=>p.id));
    /* compute actual distance using haversine and estimate travel time.
       The original implementation simply labelled the result as a Euclidean approximation.
       This version sums the haversine distance between consecutive points to get a more realistic path length.
       Travel time is estimated assuming an average speed of 30 km/h (typical for urban driving) */
    let totalDist=0;
    for(let i=0;i<order.length-1;i++){
      totalDist += dist(order[i], order[i+1]);
    }
    const km = totalDist;
    const avgSpeed = 30; // km/h
    const minutes = km / avgSpeed * 60;
    $('#routeStat').textContent = `거리: ${km.toFixed(1)}km / 시간: ${minutes.toFixed(0)}분 (내장)`;
    } finally {
      isComputing = false;
    }
  }
  // When clicking the route button we want to allow auto-fill if enabled, so call computeRoute with skipAutoFill=false
  $("#btnRoute").addEventListener('click', ()=> computeRoute(false));
  $("#btnRouteClear").addEventListener('click', ()=>{ routeLayer.clearLayers(); $$(".routeOrder").forEach(i=>i.value=""); $('#routeStat').textContent='거리: - / 시간: -'; });

  /* A/B pick */
  function enableAB(on){
    if(on){
      AB=[]; abMarkers.forEach(m=>m.remove()); abMarkers=[];
      $('#abInfo').textContent='A/B: 지도에서 두 지점을 클릭하세요';
      map.getContainer().style.cursor='crosshair';
      const handler=(e)=>{
        AB.push([e.latlng.lat, e.latlng.lng]);
        const m=L.circleMarker(e.latlng,{radius:8,color:'#EA580C'}).addTo(routeLayer); abMarkers.push(m);
        $('#abInfo').textContent=`A/B: ${AB.length}개 선택`;
        if(AB.length===2){ map.off('click', handler); map.getContainer().style.cursor=''; abRoute(); }
      };
      map.on('click', handler);
      $('#btnABReset').onclick=()=>{ map.off('click', handler); map.getContainer().style.cursor=''; AB=[]; abMarkers.forEach(m=>m.remove()); abMarkers=[]; $('#abInfo').textContent='A/B: -'; };
    }else{
      AB=[]; abMarkers.forEach(m=>m.remove()); abMarkers=[]; $('#abInfo').textContent='A/B: -';
    }
  }
  async function abRoute(){
    if(AB.length<2) return;
    const engine=$('#engine').value;
    if(engine==='osrm'){
      try{
        const server=$('#osrmServer').value.replace(/\/+$/,'');
        const profile=$('#osrmProfile').value;
        const coords=[AB[0],AB[1]].map(p=>`${p[1]},${p[0]}`).join(';');
        const url=`${server}/route/v1/${profile}/${coords}?geometries=geojson&overview=full`;
        const res=await fetch(url);
        if(!res.ok) throw new Error('OSRM 응답 오류');
        const data=await res.json();
        const r=data.routes?.[0];
        if(!r) throw new Error('경로 없음');
        drawRouteLatLngs(r.geometry.coordinates.map(c=>[c[1],c[0]]));
        const m=(r.distance||0)/1000; const t=(r.duration||0)/60;
        $('#routeStat').textContent=`거리: ${m.toFixed(1)}km / 시간: ${t.toFixed(0)}분 (A/B OSRM)`;
        return;
      }catch(e){
        console.warn('OSRM A/B 실패', e);
        $('#routeStat').textContent=`OSRM 실패(A/B)`;
      }
    }else{
      // straight line
      drawRouteLatLngs(AB.map(p=>[p[0],p[1]]));
      const R=(a,b)=>Math.sqrt(Math.pow(a[0]-b[0],2)+Math.pow(a[1]-b[1],2))*111; // rough km
      const m=R(AB[0],AB[1]);
      $('#routeStat').textContent=`직선 거리: ~${m.toFixed(1)}km (내장)`;
    }
  }
  $('#btnPickAB').addEventListener('click', ()=>enableAB(true));
  $('#btnABReset').addEventListener('click', ()=>enableAB(false));

  /* panel patch + hover shield */
  (function selPanelPatch(){
    const p = $("#selPanel");
    // edges
    ["left","right","top","bottom"].forEach(k=>{
      const d=document.createElement("div"); d.className="edge e-"+k; p.appendChild(d);
    });
    const head = p.querySelector(".head");
    let dragging=false, sx=0, sy=0, sl=0, st=0;
    head.addEventListener("pointerdown", e=>{
      if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
      dragging=true; p.classList.add("dragging");
      const r=p.getBoundingClientRect();
      sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
      p.style.left=r.left+"px"; p.style.top=r.top+"px";
      p.style.right=""; p.style.bottom="";
      p.setPointerCapture(e.pointerId);
    });
    head.addEventListener("pointermove", e=>{
      if(!dragging) return;
      const dx=e.clientX-sx, dy=e.clientY-sy;
      p.style.left=(sl+dx)+"px"; p.style.top =(st+dy)+"px";
    });
    head.addEventListener("pointerup", e=>{
      if(!dragging) return;
      dragging=false; p.classList.remove("dragging");
      try{p.releasePointerCapture(e.pointerId);}catch(_){}
    });
    head.addEventListener("dblclick", ()=>{
      p.style.width=""; p.style.height="";
      p.style.left=""; p.style.top="";
      p.style.right="16px"; p.style.bottom="90px";
    });

    const minW=360, minH=180;
    let resizing=false, eg="", sx2=0, sy2=0, sw=0, sh=0, sl2=0, st2=0;
    function startResize(e, which){
      resizing=true; eg=which; p.classList.add("resizing");
      const r=p.getBoundingClientRect();
      sx2=e.clientX; sy2=e.clientY; sw=r.width; sh=r.height; sl2=r.left; st2=r.top;
      p.style.left=sl2+"px"; p.style.top=st2+"px";
      p.style.right=""; p.style.bottom="";
      p.setPointerCapture(e.pointerId);
      e.preventDefault();
    }
    function doResize(e){
      if(!resizing) return;
      const dx=e.clientX-sx2, dy=e.clientY-sy2;
      if(eg==="right"){ p.style.width=Math.max(minW, sw+dx)+"px"; }
      if(eg==="left"){  const w=Math.max(minW, sw-dx); p.style.width=w+"px"; p.style.left=(sl2+dx)+"px"; }
      if(eg==="bottom"){p.style.height=Math.max(minH, sh+dy)+"px"; }
      if(eg==="top"){   const h=Math.max(minH, sh-dy); p.style.height=h+"px"; p.style.top=(st2+dy)+"px"; }
    }
    function stopResize(e){
      if(!resizing) return;
      resizing=false; eg=""; p.classList.remove("resizing");
      try{p.releasePointerCapture(e.pointerId);}catch(_){}
    }
    p.querySelector(".e-left").addEventListener("pointerdown", ev=>startResize(ev,"left"));
    p.querySelector(".e-right").addEventListener("pointerdown", ev=>startResize(ev,"right"));
    p.querySelector(".e-top").addEventListener("pointerdown", ev=>startResize(ev,"top"));
    p.querySelector(".e-bottom").addEventListener("pointerdown", ev=>startResize(ev,"bottom"));
    p.addEventListener("pointermove", doResize);
    p.addEventListener("pointerup", stopResize);

    // *** CRITICAL: stop map interaction while hovering over panel ***
    function disableMapInteractions(){
      if(!map) return;
      map.dragging.disable(); map.scrollWheelZoom.disable(); map.doubleClickZoom.disable();
      map.touchZoom.disable(); map.boxZoom.disable(); map.keyboard.disable();
      if(L && L.DomEvent){
        L.DomEvent.disableClickPropagation(p);
        L.DomEvent.disableScrollPropagation(p);
      }
    }
    function enableMapInteractions(){
      if(!map) return;
      map.dragging.enable(); map.scrollWheelZoom.enable(); map.doubleClickZoom.enable();
      map.touchZoom.enable(); map.boxZoom.enable(); map.keyboard.enable();
    }
    p.addEventListener('mouseenter', disableMapInteractions);
    p.addEventListener('mouseleave', enableMapInteractions);
  })();

  /* buttons & binds */
  function bind(){
    // rail icon -> open section
    $$("#rail .icbtn").forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const target = btn.getAttribute('data-target'); const sec = target? document.querySelector(target): null;
        const opened = btn.classList.contains('active');
        $$("#rail .icbtn").forEach(b=>b.classList.remove('active'));
        if(opened){
          setVar('--side-w','0px'); $("#lhs").style.display='none';
        } else{
          setVar('--side-w','380px'); $("#lhs").style.display='block'; btn.classList.add('active');
          if(sec){
            document.querySelectorAll('#lhs section details').forEach(d=>d.open=false);
            sec.querySelector('details').open=true; sec.scrollIntoView({behavior:"smooth",block:"start"});
          }
        }
        setTimeout(()=>map.invalidateSize(),150);
      });
    });

    $("#btnToggleLeft").onclick=()=>{
      const open = getComputedStyle($("#lhs")).display!=='none';
      if(open){ setVar('--side-w','0px'); $("#lhs").style.display='none'; }
      else{ setVar('--side-w','380px'); $("#lhs").style.display='block'; }
      setTimeout(()=>map.invalidateSize(),150);
    };

    // files
    $("#file").addEventListener('change', async e=>{const f=e.target.files[0]; if(!f) return; await readFile(f);});
    $("#apply").addEventListener('click', toRowsManual);

    // search
    function runSearchApply(){ scopeTerm=$("#searchScope").value.trim(); rebuildFilterBoxes(false); render(true); }
    $("#searchScope").addEventListener('keydown', e=>{ if(e.key==="Enter") runSearchApply(); });
    $("#btnClearScope").addEventListener('click', ()=>{ $("#searchScope").value=''; scopeTerm=""; rebuildFilterBoxes(true); render(true); });
    $("#toggleCoordRelax").addEventListener('change', e=>{ includeRelax=e.target.checked; render(true); });
    $("#onlyUninspected").addEventListener('change', ()=>render(true));

    function syncChips(boxId){
      document.querySelector(`#${boxId}`).addEventListener('change', e=>{
        if(e.target.name==='grp' || e.target.name==='emd'){
          const val=decodeURIComponent(e.target.value);
          if(e.target.name==='grp'){ if(e.target.checked) selGrp.add(val); else selGrp.delete(val); }
          else{ if(e.target.checked) selEmd.add(val); else selEmd.delete(val); }
          refreshToggleStates(); render(true);
        }
      });
    }
    syncChips('grpBox'); syncChips('emdBox');

    // chip helpers
    $("#btnFilterAll").addEventListener('click', ()=>{
      const gi=$$('#grpChips input'); const ei=$$('#emdChips input');
      gi.forEach(x=>x.checked=true); ei.forEach(x=>x.checked=true);
      selGrp=new Set(gi.map(x=>decodeURIComponent(x.value)));
      selEmd=new Set(ei.map(x=>decodeURIComponent(x.value)));
      refreshToggleStates(); render(true);
    });
    $("#btnFilterNone").addEventListener('click', ()=>{
      $$('#grpChips input').forEach(x=>x.checked=false); $$('#emdChips input').forEach(x=>x.checked=false);
      selGrp=new Set(); selEmd=new Set(); refreshToggleStates(); render(true);
    });

    // labels/marker style
    $("#labelSrc").addEventListener('change', ()=>render(false));
    $("#markerStyle").addEventListener('change', ()=>render(false));

    // scale shortcuts
    function setScaleMeters(m){
      const center=map.getCenter(); const px=map.getSize().x*(1/3);
      const target=m/px; const zoom=Math.log2(156543.03392*Math.cos(center.lat*Math.PI/180)/target);
      map.setZoom(zoom);
    }
    $$(".scale").forEach(b=>b.addEventListener('click',()=>setScaleMeters(parseInt(b.dataset.m,10)||500)));

    // map toolbar
    $("#btnFit").onclick=()=>{
      const pts=[]; routeLayer.eachLayer(l=>{ if(l.getLatLngs){ try{ pts.push(...l.getLatLngs()); }catch(_){} } });
      if(!pts.length){ groupLayer.eachLayer(l=>{if(l.getLatLng) pts.push(l.getLatLng());}); }
      if(pts.length) map.fitBounds(L.latLngBounds(pts).pad(0.2));
    };
    $("#btnRefresh").onclick=()=>render(true);
    $("#btnToggleSel").onclick=()=>{ 
      const p=$("#selPanel"); 
      const wasHidden = p.style.display !== 'block';
      p.style.display=(p.style.display==='block'?'none':'block');
      
      // 패널을 열 때 화면 중앙으로 위치 조정
      if (wasHidden && p.style.display === 'block') {
        setTimeout(() => centerSelectionPanel(), 100);
      }
    };

    // 상단 지도 컨트롤 버튼: 기존 기능을 호출하도록 바인딩
    if($("#btnFitTop")){
      $("#btnFitTop").addEventListener('click', ()=>{
        // 기존 맞춤 버튼과 동일한 동작 수행
        $("#btnFit").onclick();
      });
    }
    if($("#btnRefreshTop")){
      $("#btnRefreshTop").addEventListener('click', ()=>{
        // 기존 필터 적용 버튼과 동일한 동작 수행
        $("#btnRefresh").onclick();
      });
    }
    if($("#btnToggleSelTop")){
      $("#btnToggleSelTop").addEventListener('click', ()=>{
        // 기존 선택목록 토글과 동일한 동작 수행
        $("#btnToggleSel").onclick();
        // 모바일에서 선택목록을 열 때 화면 중앙으로 위치 조정
        setTimeout(() => {
          const panel = $("#selPanel");
          if (panel && panel.style.display === 'block') {
            centerSelectionPanel();
          }
        }, 100);
      });
    }
    
    // 선택목록 패널을 화면 중앙으로 이동시키는 함수
    function centerSelectionPanel() {
      const panel = $("#selPanel");
      if (!panel) return;
      
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const panelRect = panel.getBoundingClientRect();
      
      // 모바일/태블릿 감지
      const isMobile = viewportWidth <= 768;
      const isTablet = viewportWidth > 768 && viewportWidth <= 1024;
      
      if (isMobile) {
        // 모바일: 화면 중앙, 적절한 크기로 조정
        const idealWidth = Math.min(350, viewportWidth - 32);
        const idealHeight = Math.min(400, viewportHeight - 120);
        
        panel.style.width = idealWidth + 'px';
        panel.style.height = idealHeight + 'px';
        panel.style.left = ((viewportWidth - idealWidth) / 2) + 'px';
        panel.style.top = '80px';
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';
      } else if (isTablet) {
        // 태블릿: 화면 중앙, 더 큰 크기
        const idealWidth = Math.min(500, viewportWidth - 64);
        const idealHeight = Math.min(500, viewportHeight - 120);
        
        panel.style.width = idealWidth + 'px';
        panel.style.height = idealHeight + 'px';
        panel.style.left = ((viewportWidth - idealWidth) / 2) + 'px';
        panel.style.top = '80px';
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';
      } else {
        // 데스크톱: 기본 위치로 복원
        panel.style.width = '640px';
        panel.style.height = '400px';
        panel.style.left = '';
        panel.style.top = '';
        panel.style.right = '16px';
        panel.style.bottom = '90px';
      }
    }

    // selection load
    $("#btnSelLoad").addEventListener('click', ()=>$("#selFile").click());
    $("#selFile").addEventListener('change', async e=>{
      const f=e.target.files[0]; if(!f) return;
      const name=f.name.toLowerCase();
      if(name.endsWith('.xlsx')||name.endsWith('.xlsm')||name.endsWith('.xls')){
        const buf=await f.arrayBuffer();
        const wb2=XLSX.read(new Uint8Array(buf),{type:"array"});
        const ws=wb2.Sheets[wb2.SheetNames[0]];
        const arr=XLSX.utils.sheet_to_json(ws);
        $("#selBody").innerHTML=''; selectedIds.clear();
        for(const r of arr){
          const id = r["고유번호"] ?? r["id"] ?? r["ID"] ?? r["Id"];
          const base = rowsById.get(String(id)) || {};
          addToSel({id:String(id||""), name:r["시설명"]??base.name??"", addr:r["구분주소"]??base.addr??"", grp:r["군집"]??base.grp??"", lat:parseFloat(r["위도"]??base.lat), lng:parseFloat(r["경도"]??base.lng)});
          const last=$("#selBody tr:last-child input.routeOrder"); if(last) last.value = r["경로"]||"";
        }
      }else{
        const txt=await f.text();
        const lines=txt.split(/\\r?\\n/).filter(Boolean);
        const head=lines.shift().split(/\\t|,/);
        const idx=(name)=>head.findIndex(h=>h.trim()===name);
        const iId=idx("고유번호"), iName=idx("시설명"), iAddr=idx("구분주소"), iGrp=idx("군집"), iLat=idx("위도"), iLng=idx("경도"), iRoute=idx("경로");
        $("#selBody").innerHTML=''; selectedIds.clear();
        for(const line of lines){
          const t=line.split(/\\t|,/);
          const id=t[iId]; const base=rowsById.get(String(id))||{};
          addToSel({id:String(id||""), name:t[iName]??base.name??"", addr:t[iAddr]??base.addr??"", grp:t[iGrp]??base.grp??"", lat:parseFloat(t[iLat]??base.lat), lng:parseFloat(t[iLng]??base.lng)});
          const last=$("#selBody tr:last-child input.routeOrder"); if(last) last.value = t[iRoute]||"";
        }
      }
      alert("선택목록이 로드되었습니다.");
      e.target.value='';
    });

    // left width drag
    (function(){
      let dragging=false,sx,sw;
      $("#gut").addEventListener('mousedown',e=>{dragging=true;sx=e.clientX;sw=parseInt(getComputedStyle(document.documentElement).getPropertyValue('--side-w'))||380; document.body.style.cursor='col-resize'; e.preventDefault();});
      window.addEventListener('mousemove',e=>{if(!dragging) return; const w=Math.min(640,Math.max(0, sw+(e.clientX-sx))); setVar('--side-w',w+'px'); $("#lhs").style.display = (w===0?'none':'block'); map.invalidateSize();});
      window.addEventListener('mouseup',()=>{if(dragging){dragging=false; document.body.style.cursor='';}});
    })();

    // PDF
    $("#btnPDFMap").onclick=async()=>{
      const {jsPDF}=window.jspdf; if(!jsPDF){alert("jsPDF 로더 오류"); return;}
      const mapEl=$("#map");
      const scale=parseInt($("#capScale").value)||2;
      const canvas=await html2canvas(mapEl,{scale, useCORS:true, backgroundColor:"#ffffff"});
      const pdf=new jsPDF({orientation:'l',unit:'mm',format:'a4',compress:true});
      const pageW=pdf.internal.pageSize.getWidth(), pageH=pdf.internal.pageSize.getHeight();
      const mg=5; const maxW=pageW-mg*2, maxH=pageH-mg*2, ratio=canvas.width/canvas.height;
      let w=maxW, h=maxW/ratio; if(h>maxH){h=maxH; w=maxH*ratio;}
      const x=(pageW-w)/2, y=(pageH-h)/2;
      pdf.addImage(canvas.toDataURL("image/jpeg",0.92),"JPEG",x,y,w,h,"","FAST");
      pdf.save("지도.pdf");
    };
    $("#btnPDFScreen").onclick=async()=>{
      const {jsPDF}=window.jspdf; if(!jsPDF){alert("jsPDF 로더 오류"); return;}
      const canvas=await html2canvas(document.body,{scale:parseInt($("#capScale").value)||2,useCORS:true,backgroundColor:"#ffffff"});
      const pdf=new jsPDF({orientation:($("#capOrient").value==='l'?'l':'p'),unit:'mm',format:'a4',compress:true});
      const pageW=pdf.internal.pageSize.getWidth(), pageH=pdf.internal.pageSize.getHeight();
      const mg=(parseFloat($("#capMargin").value)||0.7)*10;
      const maxW=pageW-mg*2, maxH=pageH-mg*2, ratio=canvas.width/canvas.height;
      let w=maxW, h=maxW/ratio; if(h>maxH){h=maxH; w=maxH*ratio;}
      const x=(pageW-w)/2, y=(pageH-h)/2;
      pdf.addImage(canvas.toDataURL("image/jpeg",0.92),"JPEG",x,y,w,h,"","FAST");
      pdf.save("현재화면_캡처.pdf");
    };
    $("#toggleBW").addEventListener('change',e=>{ document.body.classList.toggle('bw',e.target.checked); });

    $('#darkToggle').addEventListener('change', e=>{ document.body.classList.toggle('dark', e.target.checked); });
  }

  function updateFontVars(){ setVar('--tbl-font', tblFont+'px'); setVar('--flt-font', fltFont+'px'); setVar('--mk', mk+'px'); }

  function init(){
    setupMap(); bind();
    $("#btnTblUp").onclick=()=>{ tblFont=Math.min(18,++tblFont); updateFontVars(); };
    $("#btnTblDn").onclick=()=>{ tblFont=Math.max(10,--tblFont); updateFontVars(); };
    $("#btnFltUp").onclick=()=>{ fltFont=Math.min(18,++fltFont); updateFontVars(); };
    $("#btnFltDn").onclick=()=>{ fltFont=Math.max(11,--fltFont); updateFontVars(); };
    $("#btnMkUp").onclick =()=>{ mk=Math.min(44,mk+4); updateFontVars(); render(false); };
    $("#btnMkDn").onclick =()=>{ mk=Math.max(20,mk-4); updateFontVars(); render(false); };
  }
  return { init };
})();
</script><script>
(function(){
  const $ = (q,root=document)=>root.querySelector(q);
  const $$ = (q,root=document)=>Array.from(root.querySelectorAll(q));

  /* -----------------------------------------------------------
   * 1) 선택목록 패널: 튕김 방지(지도 상호작용 차단) + 드래그 + 4변 리사이즈
   * ---------------------------------------------------------*/
  const panel = document.getElementById('selPanel');
  if(panel){
    // 리사이즈 엣지 없으면 생성
    if(!panel.querySelector('.e-left')){
      ['left','right','top','bottom'].forEach(k=>{
        const d=document.createElement('div'); d.className='edge e-'+k; panel.appendChild(d);
      });
    }

    // 지도 차단 실드
    const map = document.getElementById('map');
    const shield = document.getElementById('mapShield');
    function showShield(){ if(map) shield.style.display='block'; }
    function hideShield(){ shield.style.display='none'; }
    // 패널에 마우스 들어오면 지도 드래그/휠/더블클릭 모두 차단
    function blockMapInteractions(){
      showShield();
      // 패널 내부 스크롤/휠/터치도 전파 차단
      const stop = e=>{ e.preventDefault(); e.stopPropagation(); };
      panel.addEventListener('wheel', stop, {passive:false});
      panel.addEventListener('touchmove', stop, {passive:false});
      panel.__stop = stop;
      // Leaflet 쪽도 추가 안전장치
      if(window.L && L.DomEvent){
        try{ L.DomEvent.disableClickPropagation(panel); L.DomEvent.disableScrollPropagation(panel); }catch(_){}
      }
    }
    function unblockMapInteractions(){
      hideShield();
      if(panel.__stop){
        panel.removeEventListener('wheel', panel.__stop, {passive:false});
        panel.removeEventListener('touchmove', panel.__stop, {passive:false});
        panel.__stop=null;
      }
    }
    panel.addEventListener('mouseenter', blockMapInteractions);
    panel.addEventListener('mouseleave', unblockMapInteractions);

    // 드래그(헤더 더블클릭 → 기본 위치 복원)
    const head = panel.querySelector('.head') || panel;
    let dragging=false, sx=0, sy=0, sl=0, st=0;
    head.addEventListener('mousedown', e=>{
      // 버튼/입력 위에서는 드래그 시작 안 함
      if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
      const r=panel.getBoundingClientRect();
      dragging=true; panel.classList.add('dragging');
      sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
      panel.style.left=r.left+'px'; panel.style.top=r.top+'px';
      panel.style.right=''; panel.style.bottom='';
      document.body.style.userSelect='none';
      showShield(); // 드래그 중에도 지도 차단
      e.preventDefault();
    });
    window.addEventListener('mousemove', e=>{
      if(!dragging) return;
      panel.style.left = (sl + (e.clientX - sx)) + 'px';
      panel.style.top  = (st + (e.clientY - sy)) + 'px';
    });
    window.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging=false; panel.classList.remove('dragging');
      document.body.style.userSelect='';
      hideShield();
    });
    head.addEventListener('dblclick', ()=>{
      panel.style.width=''; panel.style.height='';
      panel.style.left=''; panel.style.top='';
      panel.style.right='16px'; panel.style.bottom='90px';
    });

    // 4변 리사이즈
    (function edgeResize(){
      const minW=360, minH=220;
      let resizing=false, edge='', sx=0, sy=0, sw=0, sh=0, sl=0, st=0;
      function start(e, which){
        const r=panel.getBoundingClientRect();
        resizing=true; edge=which;
        sx=e.clientX; sy=e.clientY; sw=r.width; sh=r.height; sl=r.left; st=r.top;
        panel.style.left = sl+'px'; panel.style.top = st+'px';
        panel.style.right=''; panel.style.bottom='';
        document.body.style.cursor=(which==='left'||which==='right')?'ew-resize':'ns-resize';
        showShield();
        e.preventDefault();
      }
      function move(e){
        if(!resizing) return;
        const dx=e.clientX-sx, dy=e.clientY-sy;
        if(edge==='right'){ panel.style.width = Math.max(minW, sw+dx) + 'px'; }
        if(edge==='left' ){ const w=Math.max(minW, sw-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
        if(edge==='bottom'){ panel.style.height= Math.max(minH, sh+dy) + 'px'; }
        if(edge==='top'   ){ const h=Math.max(minH, sh-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
      }
      function stop(){
        if(!resizing) return;
        resizing=false; edge=''; document.body.style.cursor=''; hideShield();
        window.removeEventListener('mousemove', move);
        window.removeEventListener('mouseup', stop);
      }
      panel.querySelector('.e-left')  .addEventListener('mousedown', e=>{start(e,'left');  window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);});
      panel.querySelector('.e-right') .addEventListener('mousedown', e=>{start(e,'right'); window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);});
      panel.querySelector('.e-top')   .addEventListener('mousedown', e=>{start(e,'top');   window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);});
      panel.querySelector('.e-bottom').addEventListener('mousedown', e=>{start(e,'bottom');window.addEventListener('mousemove', move); window.addEventListener('mouseup', stop);});
    })();
  }

  /* -----------------------------------------------------------
   * 2) 경로 외 마커 숨김 토글(경로 계산 후 라우트에 포함되지 않은 마커를 숨김)
   *    - 표의 첫번째 열(고유번호)을 기준으로 판별
   *    - 라벨이 고유번호가 아닐 때도 동작하도록 마커 DOM에서 숫자 추출 시도
   * ---------------------------------------------------------*/
  // 토글 UI를 경로 섹션 카드에 주입
  (function injectToggle(){
    const host = document.querySelector('#secRoute .card') || document.querySelector('#secRoute');
    if(!host || document.getElementById('toggleHideNonRoute')) return;
    const wrap = document.createElement('div');
    wrap.style.cssText='margin-top:8px; display:flex; align-items:center; gap:8px; flex-wrap:wrap;';
    wrap.innerHTML = `
      <label class="chip" style="user-select:none">
        <input type="checkbox" id="toggleHideNonRoute"> 경로 외 마커 숨김
      </label>
      <span class="small">※ 표의 <b>고유번호</b>를 기준으로 숨김 처리</span>
    `;
    host.appendChild(wrap);
    document.getElementById('toggleHideNonRoute').addEventListener('change', applyRouteFilter);
  })();

  // 현재 표의 "경로 순번"이 들어간 행의 고유번호 집합 구하기
  function currentRouteIdSet(){
    const set = new Set();
    $$('#selBody tr').forEach(tr=>{
      const id = (tr.querySelector('td')?.innerText||'').trim();
      const ord = tr.querySelector('input.routeOrder')?.value?.trim() || '';
      if(id && ord) set.add(String(id));
    });
    return set;
  }

  // 마커 DOM에서 숫자형 아이디 추출 (라벨이 이름/주소여도 숫자 묶음이 있으면 시도)
  function readMarkerIdFromEl(el){
    if(!el) return '';
    // divIcon의 첫번째 자식이 mk* 박스
    const box = el.querySelector('.mk, .mk-circle, .mk-bubble, .mk-tag') || el.firstElementChild;
    const t = (box?.textContent||'').trim();
    // "1234" 또는 "1234 · ..." 등에서 숫자만 추출
    const m = t.match(/\d{2,}/);  // 최소 2자리
    return m ? m[0] : t;
  }

  function iterMarkerBoxes(){
    // Leaflet divIcon 마커 컨테이너
    return $$('.leaflet-marker-pane > div');
  }

  function applyRouteFilter(){
    const on = document.getElementById('toggleHideNonRoute')?.checked;
    if(!on){
      iterMarkerBoxes().forEach(el=>el.classList.remove('clo-hidden'));
      return;
    }
    const routeIds = currentRouteIdSet();
    if(routeIds.size===0){
      // 순번이 없다면 숨김 해제
      iterMarkerBoxes().forEach(el=>el.classList.remove('clo-hidden'));
      return;
    }
    iterMarkerBoxes().forEach(el=>{
      const id = readMarkerIdFromEl(el);
      if(routeIds.has(String(id))) el.classList.remove('clo-hidden');
      else el.classList.add('clo-hidden');
    });
  }

  // 경로 계산/초기화 버튼에 연동 (존재하는 경우에만)
  (function hookRouteButtons(){
    const btnCalc  = document.getElementById('btnRoute');
    const btnClear = document.getElementById('btnRouteClear');
    if(btnCalc){
      btnCalc.addEventListener('click', ()=>{
        // 계산 후 DOM 업데이트 타이밍 고려해 약간 늦게 적용
        setTimeout(applyRouteFilter, 50);
      }, {capture:true});
    }
    if(btnClear){
      btnClear.addEventListener('click', ()=>{
        setTimeout(()=>{ 
          // 표 순번/경로 지우면 마커 전부 다시 보이게
          const tog = document.getElementById('toggleHideNonRoute'); 
          if(tog) tog.checked = false;
          applyRouteFilter();
        }, 0);
      }, {capture:true});
    }
    // 표 편집/삭제 등에도 반응
    const selBody = document.getElementById('selBody');
    if(selBody){
      selBody.addEventListener('input', e=>{
        if(e.target.classList.contains('routeOrder')) applyRouteFilter();
      });
      selBody.addEventListener('click', e=>{
        if(e.target.classList.contains('btn-del')) setTimeout(applyRouteFilter, 0);
      });
    }
  })();

  // 지도가 다시 그려질 때(필터/리렌더 후)도 한 번 더 적용되도록 MutationObserver
  (function observeMarkerPane(){
    const pane = document.querySelector('.leaflet-marker-pane');
    if(!pane || window.__cloMO) return;
    const mo = new MutationObserver(()=>{ 
      // 마커 DOM이 바뀌면 현재 토글 상태로 다시 적용
      if(document.getElementById('toggleHideNonRoute')?.checked) applyRouteFilter();
    });
    mo.observe(pane, {childList:true, subtree:true});
    window.__cloMO = mo;
  })();

  /*
   * 알고리즘 사용법 툴팁
   * routeMethod 또는 engine 드롭다운에 마우스를 올리면 해당 알고리즘의 설명을 보여줍니다.
   */
  (function setupAlgoTooltip(){
    // 설명 사전
    const tips = {
      // 내장 및 최근점 알고리즘: 인접 시설을 빠르게 방문하는 근사 방식입니다.
      'nn2opt':'내장 알고리즘: 가까운 시설을 먼저 방문한 다음 경로를 조금씩 바꿔 거리를 줄이는 방식입니다.',
      'nn':'최근점 알고리즘: 현재 위치에서 가장 가까운 시설부터 차례대로 이동하는 단순한 방법입니다.',
      // 클러스터: 공간을 여러 구역으로 나누어 각 구역 안에서 순서를 찾는 방식입니다.
      'cluster':'클러스터: 가까운 시설들을 여러 구역으로 묶어 각 구역 안에서 최적 순서를 찾습니다. 먼 거리를 한 번에 도는 대신 근처 구역을 집중적으로 돌아봅니다.',
      'hilbert':'힐버트: 지도를 지그재그로 채우는 궤적을 따라 이동합니다. 인접한 시설을 자연스럽게 이어 주어 한 바퀴 크게 도는 구간을 줄입니다.',
      'kmeans':'K-평균: 전체 시설을 몇 개의 그룹으로 나눈 후 그룹별로 경로를 계산합니다. 각 그룹을 순서대로 방문해 작업 구역을 뭉쳐서 처리할 때 유용합니다.',
      'builtin':'내장: 가까운 시설부터 2-opt로 개선하는 기본 알고리즘입니다.',
      'osrm':'OSRM: 인터넷 OSRM 서버를 사용해 실제 도로를 따라 가장 짧은 경로를 찾습니다.'
    };
    // 툴팁 요소 생성
    const tip=document.createElement('div');
    tip.id='algoTooltip';
    tip.style.cssText='position:absolute; z-index:10000; background:#fefce8; border:1px solid #facc15; padding:6px 8px; border-radius:6px; font-size:12px; color:#78350f; display:none; max-width:260px; box-shadow:0 2px 6px rgba(0,0,0,0.15);';
    document.body.appendChild(tip);
    function show(e){
      const val = e.target.value;
      const msg = tips[val];
      if(!msg){ tip.style.display='none'; return; }
      tip.textContent = msg;
      const rect = e.target.getBoundingClientRect();
      tip.style.left = (rect.left + window.scrollX) + 'px';
      tip.style.top = (rect.bottom + window.scrollY + 4) + 'px';
      tip.style.display = 'block';
    }
    function hide(){ tip.style.display = 'none'; }
    ['routeMethod','engine'].forEach(id=>{
      const el=document.getElementById(id);
      if(!el) return;
      el.addEventListener('mouseenter', show);
      el.addEventListener('mousemove', show);
      el.addEventListener('mouseleave', hide);
      el.addEventListener('change', show);
    });
  })();

})();
</script><script>
(function(){
  const $=(q,root=document)=>root.querySelector(q);
  const $$=(q,root=document)=>Array.from(root.querySelectorAll(q));

  /* A. 선택목록 패널: 튕김 방지 + 드래그 + 4변 리사이즈 */
  (function setupPanel(){
    const panel = $('#selPanel'); const shield = $('#mapShield');
    if(!panel || !shield) return;

    // 엣지 핸들 없으면 생성
    if(!panel.querySelector('.e-left')){
      ['left','right','top','bottom'].forEach(k=>{
        const d=document.createElement('div'); d.className='edge e-'+k; panel.appendChild(d);
      });
    }

    const stop=(e)=>{ e.preventDefault(); e.stopPropagation(); };
    const showShield=()=>{ shield.style.display='block'; };
    const hideShield=()=>{ shield.style.display='none'; };

    // 패널 hover 시 지도 상호작용 차단
    panel.addEventListener('mouseenter', ()=>{
      showShield();
      panel.addEventListener('wheel', stop, {passive:false});
      panel.addEventListener('touchmove', stop, {passive:false});
      if(window.L && L.DomEvent){
        try{ L.DomEvent.disableClickPropagation(panel); L.DomEvent.disableScrollPropagation(panel); }catch(_){}
      }
    });
    panel.addEventListener('mouseleave', ()=>{
      hideShield();
      panel.removeEventListener('wheel', stop, {passive:false});
      panel.removeEventListener('touchmove', stop, {passive:false});
    });

    // 드래그 (헤더 더블클릭 → 기본 위치 복원)
    const head = panel.querySelector('.head') || panel;
    let dragging=false, sx=0, sy=0, sl=0, st=0;
    head.addEventListener('mousedown', (e)=>{
      if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
      const r=panel.getBoundingClientRect();
      dragging=true; panel.classList.add('dragging');
      sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
      panel.style.left=sl+'px'; panel.style.top=st+'px';
      panel.style.right=''; panel.style.bottom='';
      document.body.style.userSelect='none';
      showShield();
      e.preventDefault();
    });
    window.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      panel.style.left=(sl+(e.clientX-sx))+'px';
      panel.style.top =(st+(e.clientY-sy))+'px';
    });
    window.addEventListener('mouseup', ()=>{
      if(!dragging) return;
      dragging=false; panel.classList.remove('dragging');
      document.body.style.userSelect='';
      hideShield();
    });
    head.addEventListener('dblclick', ()=>{
      panel.style.width=''; panel.style.height='';
      panel.style.left='';  panel.style.top='';
      panel.style.right='16px'; panel.style.bottom='90px';
    });

    // 4변 리사이즈
    (function edgeResize(){
      const minW=360, minH=220;
      let resizing=false, edge='', sx=0, sy=0, sw=0, sh=0, sl=0, st=0;
      function start(e, which){
        const r=panel.getBoundingClientRect();
        resizing=true; edge=which;
        sx=e.clientX; sy=e.clientY; sw=r.width; sh=r.height; sl=r.left; st=r.top;
        panel.style.left=sl+'px'; panel.style.top=st+'px';
        panel.style.right=''; panel.style.bottom='';
        document.body.style.cursor=(which==='left'||which==='right')?'ew-resize':'ns-resize';
        showShield(); e.preventDefault();
        window.addEventListener('mousemove', move);
        window.addEventListener('mouseup', stop);
      }
      function move(e){
        if(!resizing) return;
        const dx=e.clientX-sx, dy=e.clientY-sy;
        if(edge==='right'){ panel.style.width = Math.max(minW, sw+dx)+'px'; }
        if(edge==='left' ){ const w=Math.max(minW, sw-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
        if(edge==='bottom'){ panel.style.height= Math.max(minH, sh+dy)+'px'; }
        if(edge==='top'   ){ const h=Math.max(minH, sh-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
      }
      function stop(){
        if(!resizing) return;
        resizing=false; edge=''; document.body.style.cursor=''; hideShield();
        window.removeEventListener('mousemove', move);
        window.removeEventListener('mouseup', stop);
      }
      panel.querySelector('.e-left')  .addEventListener('mousedown', e=>start(e,'left'));
      panel.querySelector('.e-right') .addEventListener('mousedown', e=>start(e,'right'));
      panel.querySelector('.e-top')   .addEventListener('mousedown', e=>start(e,'top'));
      panel.querySelector('.e-bottom').addEventListener('mousedown', e=>start(e,'bottom'));
    })();
  })();

  /* B. 경로 외 마커 숨김 토글 주입 + 적용 */
  (function hideNonRoutePatch(){
    // UI 주입(없을 때만)
    const host = document.querySelector('#secRoute .card') || document.querySelector('#secRoute');
    if(host && !document.getElementById('toggleHideNonRoute')){
      const wrap=document.createElement('div');
      wrap.style.cssText='margin-top:8px;display:flex;align-items:center;gap:8px;flex-wrap:wrap;';
      wrap.innerHTML='<label class="chip" style="user-select:none"><input type="checkbox" id="toggleHideNonRoute"> 경로 외 마커 숨김</label><span class="small">※ 표의 <b>고유번호</b>와 경로순번 기준</span>';
      host.appendChild(wrap);
    }

    const getRouteIdSet=()=>{
      const s=new Set();
      $$('#selBody tr').forEach(tr=>{
        const id=(tr.querySelector('td')?.innerText||'').trim();
        const ord=tr.querySelector('input.routeOrder')?.value?.trim();
        if(id && ord) s.add(String(id));
      });
      return s;
    };
    const markerBoxes=()=>$$('.leaflet-marker-pane > div');
    const readIdFromEl=(el)=>{
      const box=el.querySelector('.mk,.mk-circle,.mk-bubble,.mk-tag')||el.firstElementChild;
      const t=(box?.textContent||'').trim();
      const m=t.match(/\d{2,}/); // 숫자 라벨 우선
      return m?m[0]:t;
    };
    const apply=()=>{
      const tog=$('#toggleHideNonRoute'); if(!tog){return;}
      if(!tog.checked){ markerBoxes().forEach(el=>el.classList.remove('clo-hidden')); return; }
      const ids=getRouteIdSet();
      if(!ids.size){ markerBoxes().forEach(el=>el.classList.remove('clo-hidden')); return; }
      markerBoxes().forEach(el=>{
        const id=readIdFromEl(el);
        if(ids.has(String(id))) el.classList.remove('clo-hidden');
        else el.classList.add('clo-hidden');
      });
    };

    // 바인딩
    $('#toggleHideNonRoute')?.addEventListener('change', apply);
    $('#selBody')?.addEventListener('input', e=>{ if(e.target.classList.contains('routeOrder')) apply(); });
    $('#selBody')?.addEventListener('click', e=>{ if(e.target.classList.contains('btn-del')) setTimeout(apply,0); });

    // 경로 계산 직후/리렌더 후 재적용
    $('#btnRoute')?.addEventListener('click', ()=>setTimeout(apply,50), {capture:true});
    const pane=document.querySelector('.leaflet-marker-pane');
    if(pane && !window.__cloMO){
      const mo=new MutationObserver(()=>{ if($('#toggleHideNonRoute')?.checked) apply(); });
      mo.observe(pane,{childList:true,subtree:true}); window.__cloMO=mo;
    }

    // 하드 초기화에 연동
    window.__clo_unhideAll=()=>{
      const tog=$('#toggleHideNonRoute'); if(tog) tog.checked=false;
      document.querySelectorAll('.clo-hidden').forEach(el=>el.classList.remove('clo-hidden'));
    };
  })();

  /* C. 하드 초기화: 경로선/선택표시/숨김토글까지 싹 초기화 */
  (function bindHardReset(){
    function hardResetAll(){
      try{
        // 1) Leaflet 경로 오버레이 제거
        document.querySelectorAll('.leaflet-overlay-pane svg path, .leaflet-overlay-pane svg polyline')
          .forEach(el=>{ try{ el.remove(); }catch(_){} });
        // 2) 경로 순번 입력칸 비움
        document.querySelectorAll('input.routeOrder').forEach(i=>i.value='');
        // 3) 마커 선택 강조 해제
        document.querySelectorAll('.mk-bubble.sel, .mk-circle.sel, .mk-tag.sel')
          .forEach(el=>el.classList.remove('sel'));
        // 4) 경로 외 숨김 해제
        window.__clo_unhideAll && window.__clo_unhideAll();
        // 5) 상태 텍스트 리셋
        const ab=$('#abInfo'); if(ab) ab.textContent='A/B: -';
        const rs=$('#routeStat'); if(rs) rs.textContent='거리: - / 시간: -';
      }catch(e){ console.warn('hardResetAll', e); }
    }
    // 좌측 섹션 초기화, 상단 초기화에 바인딩
    (function(){
      const left = document.getElementById('btnABReset') ||
        Array.from(document.querySelectorAll('#secRoute button')).find(b=>b.textContent.trim()==='초기화');
      if(left) left.addEventListener('click', ()=>setTimeout(hardResetAll,0), {capture:true});
      const top = document.getElementById('btnRouteClear') ||
        Array.from(document.querySelectorAll('button')).find(b=>b.textContent.trim()==='초기화');
      if(top) top.addEventListener('click',  ()=>setTimeout(hardResetAll,0), {capture:true});
    })();
  })();

  /* E. Move font/marker adjustment buttons into the settings block and wire auto‑recalculation toggle */
  (function setupSettingsPanel(){
    const block=document.getElementById('settingsBlock');
    if(block){
      const ids=['btnTblUp','btnTblDn','btnFltUp','btnFltDn','btnMkUp','btnMkDn'];
      ids.forEach(id=>{
        const el=document.getElementById(id);
        if(el){ el.style.display=''; block.appendChild(el); }
      });
    }
    // auto recalc: when route order inputs change or rows are deleted, recompute route automatically if toggle is on
    const tog=document.getElementById('toggleAutoRecalc');
    const body=document.getElementById('selBody');
    if(tog && body){
      body.addEventListener('input', e=>{
        if(e.target.classList.contains('routeOrder') && tog.checked){ computeRoute(); }
      });
      body.addEventListener('click', e=>{
        if(e.target.classList.contains('btn-del') && tog.checked){ setTimeout(()=>computeRoute(),0); }
      });
    }
  })();

  /* D. 경로 헤더 정렬: 클릭 시 오름/내림차순 토글 및 경로 자동 재계산 */
  (function initRouteHeaderSort(){
    const header = document.getElementById('routeHeader');
    if(!header) return;
    let ascending = true;
    header.style.cursor = 'pointer';
    header.addEventListener('click', ()=>{
      const body = document.getElementById('selBody');
      if(!body) return;
      const rows = Array.from(body.querySelectorAll('tr'));
      rows.sort((a,b)=>{
        const aVal = parseInt(a.querySelector('input.routeOrder')?.value || '0');
        const bVal = parseInt(b.querySelector('input.routeOrder')?.value || '0');
        return ascending ? (aVal - bVal) : (bVal - aVal);
      });
      rows.forEach(r=>body.appendChild(r));
      ascending = !ascending;
      // Trigger route recomputation to reflect new order
      if(rows.length>=2) computeRoute();
    });
  })();

})();
</script><script>
(function(){
  const panel = document.getElementById('selPanel');
  if(!panel || panel.dataset.v8Applied) return;
  panel.dataset.v8Applied = '1';

  const head = panel.querySelector('.head') || panel;
  const shield = document.getElementById('mapShield');

  const showShield = ()=>{ if(shield) shield.style.display='block'; };
  const hideShield = ()=>{ if(shield) shield.style.display='none'; };

  /* ── A. 드래그: 사이즈 고정 + 임계값(4px) + 포인터 캡처 ───────────────── */
  let dragging = false;
  let armingDrag = false;  // 임계값 돌파 전 준비상태
  let sx=0, sy=0, sl=0, st=0, startW=0, startH=0;
  const THRESH = 4;

  function onHeadDown(e){
    if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
    // v7 기존 핸들러보다 먼저 처리하고 전파 차단(충돌 방지)
    e.stopImmediatePropagation();
    e.preventDefault();

    const r = panel.getBoundingClientRect();
    // 드래그 중 크기 흔들림 방지: 현재 크기를 고정
    startW = r.width; startH = r.height;
    panel.style.width  = startW + 'px';
    panel.style.height = startH + 'px';

    sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top;
    armingDrag = true; dragging = false;

    head.setPointerCapture?.(e.pointerId);
    document.body.classList.add('clo-noselect');
    showShield();
  }
  function onHeadMove(e){
    if(!armingDrag && !dragging) return;
    const dx = e.clientX - sx, dy = e.clientY - sy;
    if(!dragging){
      if(Math.abs(dx) > THRESH || Math.abs(dy) > THRESH){
        dragging = true; armingDrag = false;
        // 위치 기준을 left/top으로 고정
        const r = panel.getBoundingClientRect();
        panel.style.left = r.left + 'px';
        panel.style.top  = r.top  + 'px';
        panel.style.right=''; panel.style.bottom='';
      } else {
        // 임계 전에는 기존 핸들러로 넘어가지 않도록 계속 캡처
        e.stopImmediatePropagation();
        return;
      }
    }
    e.stopImmediatePropagation();
    e.preventDefault();
    panel.style.left = (sl + dx) + 'px';
    panel.style.top  = (st + dy) + 'px';
  }
  function onHeadUp(e){
    if(!(armingDrag || dragging)) return;
    e.stopImmediatePropagation();
    armingDrag = false; dragging = false;
    head.releasePointerCapture?.(e.pointerId);
    document.body.classList.remove('clo-noselect');
    hideShield();
  }

  /* 포인터 이벤트(캡처 단계)로 등록 → 기존 v7 핸들러보다 먼저 동작 */
  head.addEventListener('pointerdown', onHeadDown, {capture:true});
  window.addEventListener('pointermove', onHeadMove, {capture:true});
  window.addEventListener('pointerup',   onHeadUp,   {capture:true});

  /* 더블클릭 기본 위치 복원 시에도 크기 고정 해제 대신 현재 값 유지 */
  head.addEventListener('dblclick', (e)=>{
    // v7의 복원 로직이 실행되더라도 width/height 흔들림 방지를 위해 그대로 유지
    // 필요시 아래 두 줄을 주석 해제해 원래 자동크기로 되돌릴 수 있음
    // panel.style.width=''; panel.style.height='';
  }, {capture:true});

  /* ── B. 4변 리사이즈(좌/상 무제한, 최소 120px만 유지) ─────────────────── */
  const minW=120, minH=120;

  function startResize(e, which){
    e.stopImmediatePropagation();
    e.preventDefault();

    const r = panel.getBoundingClientRect();
    startW=r.width; startH=r.height; sl=r.left; st=r.top;
    sx=e.clientX; sy=e.clientY;

    panel.style.left = sl+'px'; panel.style.top = st+'px';
    panel.style.right=''; panel.style.bottom='';

    document.body.style.cursor = (which==='left'||which==='right')?'ew-resize':'ns-resize';
    document.body.classList.add('clo-noselect');
    showShield();

    function move(ev){
      ev.stopImmediatePropagation(); ev.preventDefault();
      const dx = ev.clientX - sx, dy = ev.clientY - sy;
      if(which==='right'){ panel.style.width  = Math.max(minW, startW+dx) + 'px'; }
      if(which==='left' ){ const w=Math.max(minW, startW-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
      if(which==='bottom'){panel.style.height = Math.max(minH, startH+dy) + 'px'; }
      if(which==='top'   ){ const h=Math.max(minH, startH-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
    }
    function up(ev){
      ev.stopImmediatePropagation(); 
      document.removeEventListener('pointermove', move, true);
      document.removeEventListener('pointerup',   up,   true);
      document.body.style.cursor='';
      document.body.classList.remove('clo-noselect');
      hideShield();
    }
    document.addEventListener('pointermove', move, true);
    document.addEventListener('pointerup',   up,   true);
  }

  // 엣지 핸들에 v8 리사이즈 바인딩(캡처 단계)
  const el = panel.querySelector('.e-left');
  const er = panel.querySelector('.e-right');
  const et = panel.querySelector('.e-top');
  const eb = panel.querySelector('.e-bottom');
  if(el) el.addEventListener('pointerdown', e=>startResize(e,'left'),  {capture:true});
  if(er) er.addEventListener('pointerdown', e=>startResize(e,'right'), {capture:true});
  if(et) et.addEventListener('pointerdown', e=>startResize(e,'top'),   {capture:true});
  if(eb) eb.addEventListener('pointerdown', e=>startResize(e,'bottom'),{capture:true});

})();
</script><script>
(function(){
  const panel = document.getElementById('selPanel');
  if(!panel || panel.dataset.cloV9Applied) return;
  panel.dataset.cloV9Applied = '1';

  const head = panel.querySelector('.head') || panel;
  const shield = document.getElementById('mapShield');

  const showShield = ()=>{ if(shield) shield.style.display='block'; };
  const hideShield = ()=>{ if(shield) shield.style.display='none'; };

  /* ── 0) 최초 고정 앵커: right/bottom → left/top 으로 ‘핀’ 고정 ─────────── */
  (function pinPanelOnce(){
    const r = panel.getBoundingClientRect();
    // 이미 사용자가 위치를 만졌다면 건들지 않음
    if(panel.style.left || panel.style.top) return;
    panel.style.left = (r.left || (window.innerWidth - r.width - 16)) + 'px';
    panel.style.top  = (r.top  || (window.innerHeight - r.height - 90)) + 'px';
    panel.style.right = ''; panel.style.bottom = '';
  })();

  // 리사이즈 핸들 없으면 생성
  if(!panel.querySelector('.e-left')){
    ['left','right','top','bottom'].forEach(k=>{
      const d=document.createElement('div'); d.className='edge e-'+k; panel.appendChild(d);
    });
  }

  /* ── 1) Hover로는 절대 이동/리사이즈 시작 안 함(오인 방지) ─────────────── */
  const THRESH = 4;                       // 드래그 시작 임계값
  let arming=false, dragging=false;       // 드래그 준비/진행
  let sx=0, sy=0, sl=0, st=0, sw=0, sh=0; // 시작 좌표/패널치수
  const minW=120, minH=120;

  // 지도 이벤트 차단(hover만으로는 패널 이동 안 함)
  const stop = e=>{ e.preventDefault(); e.stopPropagation(); };
  panel.addEventListener('mouseenter', ()=>{
    // hover 때 지도 상호작용만 막는다(패널 이동은 arm 상태 아니면 시작 안 함)
    showShield();
    panel.addEventListener('wheel', stop, {passive:false});
    panel.addEventListener('touchmove', stop, {passive:false});
    if(window.L && L.DomEvent){
      try{ L.DomEvent.disableClickPropagation(panel); L.DomEvent.disableScrollPropagation(panel); }catch(_){}
    }
  });
  panel.addEventListener('mouseleave', ()=>{
    if(!dragging) hideShield(); // 드래그/리사이즈 중이 아니라면 해제
    panel.removeEventListener('wheel', stop, {passive:false});
    panel.removeEventListener('touchmove', stop, {passive:false});
  });

  /* ── 2) 드래그: 반드시 pointerdown 이후 4px↑ 이동해야 시작 ─────────────── */
  function onHeadDown(e){
    if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
    // 기존 핸들러보다 먼저 먹게 하고, hover-ghost 완전 차단
    e.stopImmediatePropagation(); e.preventDefault();

    const r=panel.getBoundingClientRect();
    sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top; sw=r.width; sh=r.height;

    // 이동 중 사이즈 흔들림 방지: 현재 크기를 px로 고정
    panel.style.width = sw+'px'; panel.style.height = sh+'px';
    // 항상 left/top 기준으로 이동
    panel.style.left = sl+'px'; panel.style.top = st+'px'; panel.style.right=''; panel.style.bottom='';

    arming=true; dragging=false;
    head.setPointerCapture?.(e.pointerId);
    document.body.classList.add('clo-noselect');
    showShield();
  }
  function onHeadMove(e){
    if(!arming && !dragging) return;
    const dx=e.clientX-sx, dy=e.clientY-sy;
    if(!dragging){
      if(Math.abs(dx)>THRESH || Math.abs(dy)>THRESH){
        dragging=true; arming=false;
      }else{
        e.stopImmediatePropagation(); // 임계 전엔 어떤 이동도 금지
        return;
      }
    }
    e.stopImmediatePropagation(); e.preventDefault();
    panel.style.left = (sl+dx)+'px';
    panel.style.top  = (st+dy)+'px';
  }
  function onHeadUp(e){
    if(!(arming||dragging)) return;
    e.stopImmediatePropagation();
    arming=false; dragging=false;
    head.releasePointerCapture?.(e.pointerId);
    document.body.classList.remove('clo-noselect');
    hideShield();
  }

  head.addEventListener('pointerdown', onHeadDown, {capture:true});
  window.addEventListener('pointermove', onHeadMove, {capture:true});
  window.addEventListener('pointerup',   onHeadUp,   {capture:true});
  head.addEventListener('dblclick', (e)=>{
    // 원위치로 되돌리고 싶다면 아래 주석 해제
    // panel.style.width=''; panel.style.height='';
    // panel.style.left=''; panel.style.top=''; panel.style.right='16px'; panel.style.bottom='90px';
  }, {capture:true});

  /* ── 3) 4변 리사이즈(좌/상 무제한), 드래그와 동일한 보호장치 ───────────── */
  function startResize(e, which){
    e.stopImmediatePropagation(); e.preventDefault();
    const r=panel.getBoundingClientRect();
    sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top; sw=r.width; sh=r.height;

    panel.style.left=sl+'px'; panel.style.top=st+'px';
    panel.style.right=''; panel.style.bottom='';
    document.body.style.cursor=(which==='left'||which==='right')?'ew-resize':'ns-resize';
    document.body.classList.add('clo-noselect');
    showShield();

    function move(ev){
      ev.stopImmediatePropagation(); ev.preventDefault();
      const dx=ev.clientX-sx, dy=ev.clientY-sy;
      if(which==='right'){ panel.style.width = Math.max(minW, sw+dx)+'px'; }
      if(which==='left' ){ const w=Math.max(minW, sw-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
      if(which==='bottom'){ panel.style.height= Math.max(minH, sh+dy)+'px'; }
      if(which==='top'   ){ const h=Math.max(minH, sh-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
    }
    function up(ev){
      ev.stopImmediatePropagation();
      document.removeEventListener('pointermove', move, true);
      document.removeEventListener('pointerup',   up,   true);
      document.body.style.cursor='';
      document.body.classList.remove('clo-noselect');
      hideShield();
    }
    document.addEventListener('pointermove', move, true);
    document.addEventListener('pointerup',   up,   true);
  }
  const el=panel.querySelector('.e-left'), er=panel.querySelector('.e-right'),
        et=panel.querySelector('.e-top'),  eb=panel.querySelector('.e-bottom');
  if(el) el.addEventListener('pointerdown', e=>startResize(e,'left'),  {capture:true});
  if(er) er.addEventListener('pointerdown', e=>startResize(e,'right'), {capture:true});
  if(et) et.addEventListener('pointerdown', e=>startResize(e,'top'),   {capture:true});
  if(eb) eb.addEventListener('pointerdown', e=>startResize(e,'bottom'),{capture:true});

})();
</script><script>
(function(){
  const $=(q,root=document)=>root.querySelector(q);
  const $$=(q,root=document)=>Array.from(root.querySelectorAll(q));

  const panel = $('#selPanel'); if(!panel || panel.dataset.v10Applied) return;
  panel.dataset.v10Applied='1';

  const head   = panel.querySelector('.head') || panel;
  const shield = $('#mapShield');

  const showShield = ()=>{ if(shield) shield.style.display='block'; };
  const hideShield = ()=>{ if(shield) shield.style.display='none'; };

  /* ─────────────────────────────────────────────────────────
   * 0) 최초 표시 시 화면 정중앙 배치 (처음 1회)
   *    - 패널이 display:block 되거나, 선택목록에 첫 행이 추가되면 센터링
   * ───────────────────────────────────────────────────────── */
  function centerPanel(){
    const r = panel.getBoundingClientRect();
    const vw = window.innerWidth, vh = window.innerHeight;
    const w  = Math.max(r.width || 520, 380);
    const h  = Math.max(r.height || 260, 220);
    const left = Math.max(8, Math.round((vw - w)/2));
    const top  = Math.max(8, Math.round((vh - h)/2));
    panel.style.left = left + 'px';
    panel.style.top  = top  + 'px';
    panel.style.right=''; panel.style.bottom='';
  }
  let centeredOnce=false;

  // 패널 display 변화 감지
  const moPanel = new MutationObserver(()=>{
    const disp = getComputedStyle(panel).display;
    if(!centeredOnce && disp!=='none'){
      centerPanel(); centeredOnce=true;
    }
  });
  moPanel.observe(panel,{attributes:true,attributeFilter:['style','class']});

  // 선택목록 첫 행 추가 시에도 센터링 (초기 사용 흐름 보완)
  const selBody = $('#selBody');
  if(selBody){
    const moBody = new MutationObserver(()=>{
      if(!centeredOnce && selBody.children.length>0){
        // 패널이 숨겨져 있다면 열어주기
        if(getComputedStyle(panel).display==='none') panel.style.display='block';
        centerPanel(); centeredOnce=true;
      }
    });
    moBody.observe(selBody,{childList:true});
  }

  /* ─────────────────────────────────────────────────────────
   * 1) 리사이즈: 바깥 핸들 + 안쪽 얇은 그립 모두 지원
   *    상/하/좌/우 무제한(최소 120px) · 드래그와 동일한 실드/노셀렉트
   * ───────────────────────────────────────────────────────── */
  // 바깥 핸들 보강
  if(!panel.querySelector('.e-left')){
    ['left','right','top','bottom'].forEach(k=>{
      const d=document.createElement('div'); d.className='edge e-'+k; panel.appendChild(d);
    });
  }
  // 안쪽 그립 추가
  if(!panel.querySelector('.g-left')){
    ['left','right','top','bottom'].forEach(k=>{
      const d=document.createElement('div'); d.className='grip g-'+k; panel.appendChild(d);
    });
  }

  const minW=120, minH=120;
  function startResize(e, which){
    e.stopImmediatePropagation(); e.preventDefault();
    const r=panel.getBoundingClientRect();
    let sx=e.clientX, sy=e.clientY, sl=r.left, st=r.top, sw=r.width, sh=r.height;

    panel.style.left=sl+'px'; panel.style.top=st+'px';
    panel.style.right=''; panel.style.bottom='';
    document.body.style.cursor=(which==='left'||which==='right')?'ew-resize':'ns-resize';
    document.body.classList.add('clo-noselect');
    showShield();

    function move(ev){
      ev.stopImmediatePropagation(); ev.preventDefault();
      const dx=ev.clientX-sx, dy=ev.clientY-sy;
      if(which==='right'){ panel.style.width = Math.max(minW, sw+dx)+'px'; }
      if(which==='left' ){ const w=Math.max(minW, sw-dx); panel.style.width=w+'px'; panel.style.left=(sl+dx)+'px'; }
      if(which==='bottom'){ panel.style.height= Math.max(minH, sh+dy)+'px'; }
      if(which==='top'   ){ const h=Math.max(minH, sh-dy); panel.style.height=h+'px'; panel.style.top=(st+dy)+'px'; }
    }
    function up(ev){
      ev.stopImmediatePropagation();
      document.removeEventListener('pointermove', move, true);
      document.removeEventListener('pointerup',   up,   true);
      document.body.style.cursor=''; document.body.classList.remove('clo-noselect'); hideShield();
    }
    document.addEventListener('pointermove', move, true);
    document.addEventListener('pointerup',   up,   true);
  }
  ['.e-left','.e-right','.e-top','.e-bottom','.g-left','.g-right','.g-top','.g-bottom'].forEach(sel=>{
    const el=panel.querySelector(sel); if(!el) return;
    const side = /left/.test(sel)?'left':/right/.test(sel)?'right':/top/.test(sel)?'top':'bottom';
    el.addEventListener('pointerdown', e=>startResize(e, side), {capture:true});
  });

  /* ─────────────────────────────────────────────────────────
   * 2) 드래그: hover-ghost 방지, 임계값 4px, 포인터캡처, 사이즈 고정
   * ───────────────────────────────────────────────────────── */
  const THRESH=4;
  let arming=false, dragging=false;
  let sx=0, sy=0, sl=0, st=0, sw=0, sh=0;

  function onHeadDown(e){
    if(/BUTTON|A|INPUT|SELECT|TEXTAREA/.test(e.target.tagName)) return;
    e.stopImmediatePropagation(); e.preventDefault();

    const r=panel.getBoundingClientRect();
    sx=e.clientX; sy=e.clientY; sl=r.left; st=r.top; sw=r.width; sh=r.height;

    panel.style.width=sw+'px'; panel.style.height=sh+'px';
    panel.style.left=sl+'px'; panel.style.top=st+'px';
    panel.style.right=''; panel.style.bottom='';

    arming=true; dragging=false;
    head.setPointerCapture?.(e.pointerId);
    document.body.classList.add('clo-noselect'); showShield();
  }
  function onHeadMove(e){
    if(!arming && !dragging) return;
    const dx=e.clientX-sx, dy=e.clientY-sy;
    if(!dragging){
      if(Math.abs(dx)>THRESH || Math.abs(dy)>THRESH){ dragging=true; arming=false; }
      else{ e.stopImmediatePropagation(); return; }
    }
    e.stopImmediatePropagation(); e.preventDefault();
    panel.style.left=(sl+dx)+'px';
    panel.style.top =(st+dy)+'px';
  }
  function onHeadUp(e){
    if(!(arming||dragging)) return;
    e.stopImmediatePropagation();
    arming=false; dragging=false;
    head.releasePointerCapture?.(e.pointerId);
    document.body.classList.remove('clo-noselect'); hideShield();
  }
  head.addEventListener('pointerdown', onHeadDown, {capture:true});
  window.addEventListener('pointermove', onHeadMove, {capture:true});
  window.addEventListener('pointerup',   onHeadUp,   {capture:true});

  /* ─────────────────────────────────────────────────────────
   * 3) 표 버튼(비우기/TSV/XLSX) 다시 바인딩
   * ───────────────────────────────────────────────────────── */
  function bindTableButtons(){
    const body = $('#selBody'); if(!body) return;

    // 표 비우기
    const bClear = $('#btnClearSel');
    if(bClear && !bClear.dataset.bound){
      bClear.dataset.bound='1';
      bClear.addEventListener('click', ()=>{
        body.innerHTML='';
        // 빨간 선택 표시 해제
        $$('.mk-bubble.sel,.mk-circle.sel,.mk-tag.sel').forEach(el=>el.classList.remove('sel'));
      }, {capture:true});
    }

    // TSV 복사
    const bTSV = $('#btnCopyTSV');
    if(bTSV && !bTSV.dataset.bound){
      bTSV.dataset.bound='1';
      bTSV.addEventListener('click', async ()=>{
        const headRow = ["고유번호","시설명","구분주소","군집","위도","경도","경로"];
        const rows=[headRow.join('\t')];
        $$('#selBody tr').forEach(tr=>{
          const t=Array.from(tr.querySelectorAll('td'));
          const route=tr.querySelector('input.routeOrder')?.value||"";
          rows.push([
            t[0]?.innerText||"", t[1]?.innerText||"", t[2]?.innerText||"", t[3]?.innerText||"",
            t[4]?.innerText||"", t[5]?.innerText||"", route
          ].join('\t'));
        });
        const txt=rows.join('\n');
        try{ await navigator.clipboard.writeText(txt); alert('TSV가 복사되었습니다.'); }
        catch(_){
          const ta=document.createElement('textarea'); ta.value=txt; document.body.appendChild(ta);
          ta.select(); document.execCommand('copy'); ta.remove(); alert('TSV가 복사되었습니다.');
        }
      }, {capture:true});
    }

    // XLSX 저장
    const bXLSX = $('#btnSaveXLSX');
    if(bXLSX && !bXLSX.dataset.bound){
      bXLSX.dataset.bound='1';
      bXLSX.addEventListener('click', ()=>{
        if(!window.XLSX){ alert('XLSX 라이브러리가 로드되지 않았습니다.'); return; }
        const arr=[];
        $$('#selBody tr').forEach(tr=>{
          const t=Array.from(tr.querySelectorAll('td'));
          arr.push({
            "고유번호":t[0]?.innerText||"", "시설명":t[1]?.innerText||"", "구분주소":t[2]?.innerText||"",
            "군집":t[3]?.innerText||"", "위도":t[4]?.innerText||"", "경도":t[5]?.innerText||"",
            "경로":tr.querySelector('input.routeOrder')?.value||""
          });
        });
        const ws=XLSX.utils.json_to_sheet(arr);
        const wb=XLSX.utils.book_new(); XLSX.utils.book_append_sheet(wb,ws,"선택목록");
        XLSX.writeFile(wb,"선택목록.xlsx");
      }, {capture:true});
    }
  }
  bindTableButtons();

})();
</script><script>
(function(){
  const $=(q,root=document)=>root.querySelector(q);
  const $$=(q,root=document)=>Array.from(root.querySelectorAll(q));

  const panel = $('#selPanel');
  const shield= $('#mapShield');
  if(!panel || panel.dataset.v11Applied) return;
  panel.dataset.v11Applied='1';

  /* ▸ 버튼 동작 보강(혹시 끊겨있을 경우 재바인딩) */
  // TSV 복사
  if($('#btnCopyTSV') && !$('#btnCopyTSV').dataset.bound){
    $('#btnCopyTSV').addEventListener('click', async ()=>{
      const head=["고유번호","시설명","구분주소","군집","위도","경도","경로"];
      const out=[head.join('\t')];
      $$('#selBody tr').forEach(tr=>{
        const t=Array.from(tr.querySelectorAll('td'));
        const route=tr.querySelector('input.routeOrder')?.value||"";
        out.push([t[0]?.innerText||"", t[1]?.innerText||"", t[2]?.innerText||"", t[3]?.innerText||"", t[4]?.innerText||"", t[5]?.innerText||"", route].join('\t'));
      });
      const txt=out.join('\n');
      try{ await navigator.clipboard.writeText(txt); alert("TSV가 복사되었습니다."); }
      catch(e){ const ta=document.createElement('textarea'); ta.value=txt; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); alert("TSV가 복사되었습니다."); }
    });
    $('#btnCopyTSV').dataset.bound='1';
  }
  // XLSX 저장
  if($('#btnSaveXLSX') && !$('#btnSaveXLSX').dataset.bound){
    $('#btnSaveXLSX').addEventListener('click', ()=>{
      if(!window.XLSX){ alert('XLSX 라이브러리가 없습니다.'); return; }
      const arr=[];
      $$('#selBody tr').forEach(tr=>{
        const t=Array.from(tr.querySelectorAll('td'));
        arr.push({"고유번호":t[0]?.innerText||"", "시설명":t[1]?.innerText||"", "구분주소":t[2]?.innerText||"", "군집":t[3]?.innerText||"", "위도":t[4]?.innerText||"", "경도":t[5]?.innerText||"", "경로":tr.querySelector('input.routeOrder')?.value||""});
      });
      const ws=XLSX.utils.json_to_sheet(arr);
      const wb=XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb,ws,"선택목록");
      XLSX.writeFile(wb,"선택목록.xlsx");
    });
    $('#btnSaveXLSX').dataset.bound='1';
  }
  // 표 비우기 (선택/경로도 함께 리셋)
  if($('#btnClearSel') && !$('#btnClearSel').dataset.bound){
    $('#btnClearSel').addEventListener('click', ()=>{
      const body=$('#selBody'); if(body) body.innerHTML='';
      (window.selectedIds?.clear?.bind(window.selectedIds) || function(){})();
      // 선택 스타일 해제
      $$('.mk-bubble.sel,.mk-circle.sel,.mk-tag.sel').forEach(el=>el.classList.remove('sel'));
      // 경로 라인 제거
      try{ window.routeLayer && window.routeLayer.clearLayers && window.routeLayer.clearLayers(); }catch(_){}
      // 순번 입력 비우기/상태 리셋
      $$('input.routeOrder').forEach(i=>i.value='');
      const ab=$('#abInfo'); if(ab) ab.textContent='A/B: -';
      const st=$('#routeStat'); if(st) st.textContent='거리: - / 시간: -';
    });
    $('#btnClearSel').dataset.bound='1';
  }

  /* ▸ 드래그/리사이즈(안정화는 이전 v8/v10 유지) – 기본 동작만: 패널 위 hover 시 지도 차단 */
  const stop=(e)=>{ e.preventDefault(); e.stopPropagation(); };
  function showShield(){ shield && (shield.style.display='block'); }
  function hideShield(){ shield && (shield.style.display='none'); }
  panel.addEventListener('mouseenter', ()=>{
    showShield();
    panel.addEventListener('wheel', stop, {passive:false});
    panel.addEventListener('touchmove', stop, {passive:false});
    if(window.L && L?.DomEvent){
      try{ L.DomEvent.disableClickPropagation(panel); L.DomEvent.disableScrollPropagation(panel); }catch(_){}
    }
  });
  panel.addEventListener('mouseleave', ()=>{
    hideShield();
    panel.removeEventListener('wheel', stop, {passive:false});
    panel.removeEventListener('touchmove', stop, {passive:false});
  });

  /* ▸ 중앙 초기 위치 보정 + 경계 제한 기능 */
  function constrainPanelToViewport() {
    const vw = window.innerWidth, vh = window.innerHeight;
    const rect = panel.getBoundingClientRect();
    
    // 패널이 뷰포트 경계를 벗어나지 않도록 제한
    const minX = 0;
    const maxX = vw - rect.width;
    const minY = 0; 
    const maxY = vh - rect.height;
    
    const currentX = parseInt(panel.style.left) || rect.left;
    const currentY = parseInt(panel.style.top) || rect.top;
    
    const constrainedX = Math.max(minX, Math.min(maxX, currentX));
    const constrainedY = Math.max(minY, Math.min(maxY, currentY));
    
    if (constrainedX !== currentX || constrainedY !== currentY) {
      panel.style.left = constrainedX + 'px';
      panel.style.top = constrainedY + 'px';
      panel.style.right = '';
      panel.style.bottom = '';
    }
  }

  if(!panel.dataset.centered){
    const vw=window.innerWidth, vh=window.innerHeight;
    const r=panel.getBoundingClientRect();
    panel.style.left = Math.max(16, (vw - r.width)/2) + 'px';
    panel.style.top  = Math.max(16, (vh - r.height)/2) + 'px';
    panel.style.right = ''; panel.style.bottom = '';
    panel.dataset.centered='1';
  }
  
  // 윈도우 리사이즈 시 패널 경계 체크
  window.addEventListener('resize', constrainPanelToViewport, {passive: true});

  /* ▸ 내부 스크롤 컨테이너 상한 재해제(테마가 갱신해버리는 경우 수시 보정) */
  const scroller = Array.from(panel.children).find(el=>/overflow:auto|scroll/i.test(el.style?.overflow||''));
  function unlock(){ if(!scroller) return; scroller.style.maxHeight='none'; scroller.style.height='auto'; }
  unlock(); window.addEventListener('resize', unlock, {passive:true});
})();
</script><script>
(function() {
  'use strict';
  
  const panel = document.getElementById('selPanel');
  if (!panel || panel.dataset.mobileEnhanced) return;
  panel.dataset.mobileEnhanced = '1';
  
  // Mobile/Touch device detection
  const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  const isMobileViewport = () => window.innerWidth <= 768;
  const isTabletViewport = () => window.innerWidth > 768 && window.innerWidth <= 1024;
  
  // Enhanced touch event handling for better mobile experience
  function addTouchSupport() {
    const head = panel.querySelector('.head');
    const edges = panel.querySelectorAll('.edge');
    
    // Prevent scrolling on the panel during interactions
    function preventScroll(e) {
      if (panel.contains(e.target)) {
        e.preventDefault();
      }
    }
    
    // Enhanced drag support with touch events
    let isDragging = false;
    let isResizing = false;
    let startPos = { x: 0, y: 0 };
    let startRect = null;
    let activeEdge = null;
    
    // Universal event handling (mouse, touch, pointer)
    function getEventPos(e) {
      return {
        x: e.clientX || (e.touches && e.touches[0] ? e.touches[0].clientX : 0),
        y: e.clientY || (e.touches && e.touches[0] ? e.touches[0].clientY : 0)
      };
    }
    
    // Start dragging/resizing
    function startInteraction(e, type, edge = null) {
      const pos = getEventPos(e);
      startPos = pos;
      startRect = panel.getBoundingClientRect();
      
      if (type === 'drag') {
        isDragging = true;
        panel.style.cursor = 'grabbing';
      } else if (type === 'resize') {
        isResizing = true;
        activeEdge = edge;
      }
      
      // Prevent text selection and other default behaviors
      e.preventDefault();
      document.body.style.userSelect = 'none';
      document.body.style.webkitUserSelect = 'none';
      
      // Add event listeners to document for global tracking
      if (isTouchDevice) {
        document.addEventListener('touchmove', handleMove, { passive: false });
        document.addEventListener('touchend', endInteraction, { passive: false });
      } else {
        document.addEventListener('mousemove', handleMove, { passive: false });
        document.addEventListener('mouseup', endInteraction, { passive: false });
      }
    }
    
    // Handle movement during drag/resize
    function handleMove(e) {
      if (!isDragging && !isResizing) return;
      
      const pos = getEventPos(e);
      const deltaX = pos.x - startPos.x;
      const deltaY = pos.y - startPos.y;
      
      if (isDragging) {
        // Drag the panel
        const newLeft = Math.max(0, Math.min(window.innerWidth - startRect.width, startRect.left + deltaX));
        const newTop = Math.max(0, Math.min(window.innerHeight - startRect.height, startRect.top + deltaY));
        
        panel.style.left = newLeft + 'px';
        panel.style.top = newTop + 'px';
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';
      } else if (isResizing && activeEdge) {
        // Resize the panel based on active edge
        const minWidth = isMobileViewport() ? 280 : 360;
        const minHeight = isMobileViewport() ? 180 : 220;
        const maxWidth = window.innerWidth - 32;
        const maxHeight = window.innerHeight - 120;
        
        let newWidth = startRect.width;
        let newHeight = startRect.height;
        let newLeft = startRect.left;
        let newTop = startRect.top;
        
        switch (activeEdge) {
          case 'right':
            newWidth = Math.max(minWidth, Math.min(maxWidth, startRect.width + deltaX));
            break;
          case 'left':
            const leftDelta = Math.min(deltaX, startRect.width - minWidth);
            newWidth = Math.max(minWidth, startRect.width - leftDelta);
            newLeft = Math.max(0, startRect.left + leftDelta);
            break;
          case 'bottom':
            newHeight = Math.max(minHeight, Math.min(maxHeight, startRect.height + deltaY));
            break;
          case 'top':
            const topDelta = Math.min(deltaY, startRect.height - minHeight);
            newHeight = Math.max(minHeight, startRect.height - topDelta);
            newTop = Math.max(0, startRect.top + topDelta);
            break;
        }
        
            // Ensure panel header stays within map boundaries
        const mapContainer = document.getElementById('map');
        const mapRect = mapContainer ? mapContainer.getBoundingClientRect() : { left: 0, top: 0, right: window.innerWidth, bottom: window.innerHeight };
        const headerHeight = 50; // Approximate header height
        
        // Constrain position so header stays within map bounds
        const constrainedLeft = Math.max(mapRect.left, Math.min(mapRect.right - 200, newLeft));
        const constrainedTop = Math.max(mapRect.top, Math.min(mapRect.bottom - headerHeight, newTop));
        
        // Apply new dimensions and position
        panel.style.width = newWidth + 'px';
        panel.style.height = newHeight + 'px';
        panel.style.left = constrainedLeft + 'px';
        panel.style.top = constrainedTop + 'px';
        panel.style.right = 'auto';
        panel.style.bottom = 'auto';
      }
      
      e.preventDefault();
    }
    
    // End interaction
    function endInteraction(e) {
      isDragging = false;
      isResizing = false;
      activeEdge = null;
      panel.style.cursor = '';
      
      document.body.style.userSelect = '';
      document.body.style.webkitUserSelect = '';
      
      // Remove event listeners
      if (isTouchDevice) {
        document.removeEventListener('touchmove', handleMove);
        document.removeEventListener('touchend', endInteraction);
      } else {
        document.removeEventListener('mousemove', handleMove);
        document.removeEventListener('mouseup', endInteraction);
      }
    }
    
    // Add touch/mouse event listeners to header (for dragging)
    if (head) {
      if (isTouchDevice) {
        head.addEventListener('touchstart', (e) => {
          if (!e.target.matches('button, input, select, textarea, a')) {
            startInteraction(e, 'drag');
          }
        }, { passive: false });
      } else {
        head.addEventListener('mousedown', (e) => {
          if (!e.target.matches('button, input, select, textarea, a')) {
            startInteraction(e, 'drag');
          }
        });
      }
      
      // Enhanced double-click/tap to center
      let lastTap = 0;
      function handleDoubleTap(e) {
        const now = Date.now();
        if (now - lastTap < 300) {
          e.preventDefault();
          if (window.centerSelectionPanel) {
            window.centerSelectionPanel();
          }
        }
        lastTap = now;
      }
      
      if (isTouchDevice) {
        head.addEventListener('touchend', handleDoubleTap, { passive: false });
      } else {
        head.addEventListener('dblclick', (e) => {
          if (window.centerSelectionPanel) {
            window.centerSelectionPanel();
          }
        });
      }
    }
    
    // Add touch/mouse event listeners to edges (for resizing)
    edges.forEach(edge => {
      const edgeType = edge.className.split(' ').find(cls => cls.startsWith('e-'))?.substring(2);
      if (!edgeType) return;
      
      if (isTouchDevice) {
        edge.addEventListener('touchstart', (e) => {
          startInteraction(e, 'resize', edgeType);
        }, { passive: false });
      } else {
        edge.addEventListener('mousedown', (e) => {
          startInteraction(e, 'resize', edgeType);
        });
      }
    });
  }
  
  // Apply enhanced touch support
  addTouchSupport();
  
  // Window resize handler for responsive adjustments
  function handleWindowResize() {
    if (panel.style.display !== 'block') return;
    
    const rect = panel.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Ensure panel stays within viewport bounds
    let needsAdjustment = false;
    let newLeft = parseFloat(panel.style.left) || rect.left;
    let newTop = parseFloat(panel.style.top) || rect.top;
    let newWidth = parseFloat(panel.style.width) || rect.width;
    let newHeight = parseFloat(panel.style.height) || rect.height;
    
    // Constrain panel to stay within map boundaries
    const mapContainer = document.getElementById('map');
    const mapRect = mapContainer ? mapContainer.getBoundingClientRect() : { left: 0, top: 0, right: window.innerWidth, bottom: window.innerHeight };
    const headerHeight = 50; // Approximate header height
    
    // Constrain to map viewport with header accessibility
    if (newLeft + newWidth > mapRect.right) {
      newLeft = Math.max(mapRect.left, mapRect.right - newWidth);
      needsAdjustment = true;
    }
    if (newLeft < mapRect.left) {
      newLeft = mapRect.left;
      needsAdjustment = true;
    }
    if (newTop + headerHeight > mapRect.bottom) {
      newTop = Math.max(mapRect.top, mapRect.bottom - headerHeight);
      needsAdjustment = true;
    }
    if (newTop < mapRect.top) {
      newTop = mapRect.top;
      needsAdjustment = true;
    }
    
    // Ensure minimum size based on viewport
    const minWidth = isMobileViewport() ? 280 : 360;
    const minHeight = isMobileViewport() ? 180 : 220;
    const maxWidth = viewportWidth - 32;
    const maxHeight = viewportHeight - 120;
    
    if (newWidth < minWidth || newWidth > maxWidth) {
      newWidth = Math.max(minWidth, Math.min(maxWidth, newWidth));
      needsAdjustment = true;
    }
    if (newHeight < minHeight || newHeight > maxHeight) {
      newHeight = Math.max(minHeight, Math.min(maxHeight, newHeight));
      needsAdjustment = true;
    }
    
    if (needsAdjustment) {
      panel.style.left = newLeft + 'px';
      panel.style.top = newTop + 'px';
      panel.style.width = newWidth + 'px';
      panel.style.height = newHeight + 'px';
      panel.style.right = 'auto';
      panel.style.bottom = 'auto';
    }
  }
  
  // Debounce window resize events
  let resizeTimeout;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(handleWindowResize, 100);
  }, { passive: true });
  
  // Initial setup
  handleWindowResize();
})();
</script></body>
</html>